# Microbiome data analysis 
# Differential analysis #species

library(DESeq2)
library(stringr)
library(readr)
library(tidyr)
library(data.table)
rm(list = ls())
getwd()

#Data set:GEO
dx1<-read.csv("outwith80%data_EthioISR_asthmaControlx.csv", row.names = 1)
dx2<- read.csv("Sample_species_abundentData2x.csv")


#asthmatic_ISR_data
dx1<-read.csv("asthmaticprevalence_80%andmorex.csv", row.names = 1)
dx2<- read.csv("Design_Ethio_ISR_asthmatic.csv")

dx2

#Control_Asthmatic__ISR_data
dx1<-read.csv("Control_Ethio_ISRspecies_abundance_allData.kraken_assigned__DAA.csv", row.names = 1)
dx2<- read.csv("Design_control_ethio_ISR.csv")

#only Ethiopia 
dx1<-read.csv("outwith80%data_ethio_controlx.csv", row.names = 1)
dx2<- read.csv("metadata_ethio_only.csv")
#ISR only
dx1<-read.csv("outwith80%data_ISROnly.csv", row.names = 1)
dx2<- read.csv("Design_ISRonly_data.csv")
# control Ethiopia+ISR
dx1<-read.csv("outwith80%datax.csv", row.names = 1)
dx2<- read.csv("metaISREthi_control.csv")

head(dx2)
#removing species not seen > 10% of samples
dds <- DESeqDataSetFromMatrix(dx1 ,dx2 , design = ~Type)
dim(dds)
#smallestGroupSize <- 5
#keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
#dds <- dds[keep,]
#dim(dds)


dx2
#Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(dx1 ,dx2 , design = ~Type)
dim(dds)
dds$Type <- relevel(dds$Type, ref = "Ethio")
dds <- DESeq(dds)
res <- results(dds)
res

write.csv(res, "DEGs_species_abundance_EthiISR_Control.csv")

library(tidyverse)                           
library(phyloseq)
library(edgeR)                                   
library(limma)                                    
library(DEFormats)                             
library(DESeq2)                                    
library(apeglm)                                
library(corncob) 
library(VennDiagram)
library(readxl)
library(apeglm)

#Asthmatic+control_All#Group
setwd("C:/Users/desqz2/Desktop/Abundence_Table/corncob/species")
otu_mat<- read_excel("OTU_species_abundance_allData.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent.xlsx",)
samples_df <- read_excel("Sample_species_abundentData2x.xlsx")
samples_df

tax_mat$class

getwd()
samples_df
dim(samples_df)
dim(tax_mat)
dim(otu_mat)

#plot asthmatic_ETH_ISR
otu_mat<- read_excel("OTU_species_abundance_EthioISR_asthmatic2x.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_EthioISR_asthmatic2x.xlsx",)
samples_df <- read_excel("Sample_species_abundent_metadata.xlsx")



otu_mat<- read_excel("OTU_species_abundance_SP_DAACountdatax.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_DAA.xlsx",)
samples_df <- read_excel("Sample_species_abundentData23.xlsx")
OTU_ETH_ISR_asthmatic
Sample_species_abundent_metadata


#EthioISR_asthmatic
otu_mat<- read_excel("OTU_species_abundance_EthioISR_asthmatic.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_EthioISR_asthmatic2x.xlsx",)
samples_df <- read_excel("Sample_species_abundent_metadata.xlsx")




#EthioISR_Control
otu_mat<- read_excel("otu.xlsx")
tax_mat<- read_excel("Tanrank.xlsx",)
samples_df <- read_excel("meta.xlsx")




#OTU_ETH_ISR_Control
#Ethi0_Asthma vs Control
otu_mat<- read_excel("OTU_Ethi0_only_species_abundetData.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_Ethio_only_asthmatic.xlsx",)
samples_df <- read_excel("metadata_ethio_only.xlsx")

#plottopDAA

otu_mat<- read_excel("OTU_Ethi0_only_species_abundetData_DAA.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_Ethio_only_asthmatic_DAA.xlsx",)
samples_df <- read_excel("metadata_ethio_only.xlsx")

#ISR_Asthma vs Control

otu_mat<- read_excel("ISRonly_OTU.xlsx")
tax_mat<- read_excel("ISR_taxrank.xlsx",)
samples_df <- read_excel("ISR_meta.xlsx")

#plottopDAA

otu_mat<- read_excel("ISRonly_OTU_DAAx.xlsx")
tax_mat<- read_excel("ISR_taxrankx.xlsx",)
samples_df <- read_excel("ISR_meta.xlsx")
samples_df

#Asthma vs Control for Ethiopia&ISR
otu_mat<- read_excel("OTU_species_abundance_allData.kraken_assigned_reads2.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent.xlsx",)
samples_df <- read_excel("Sample_species_abundentData2x.xlsx")
dim(tax_mat)

#plottopDAA

otu_mat<- read_excel("OTU_species_abundance_allData.kraken_assigned_reads2.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundentx.xlsx",)
samples_df <- read_excel("Sample_species_abundentData2x.xlsx")
samples_df

#Ethic_ISR_control only
#plot
otu_mat<- read_excel("OTU_ethioISR_speciesData.xlsx")
tax_mat<- read_excel("TaxonomyRank_meta_ethioISR.xlsx",)
samples_df <- read_excel("meta_ethioISRcontrol.xlsx")

#plot AR
otu_mat<- read_excel("DEGs_AR_outwith80%data_EthioISR_asthmaControlx.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundentx_AR.xlsx",)
samples_df <- read_excel("Sample_species_abundentData2.xlsx")


dim(tax_mat)






samples_df
tax_mat
otu_mat


getwd()
samples_df
dim(samples_df)
dim(tax_mat)
dim(otu_mat)
tax_mat

class(otu_mat)

getwd()


rownames(otu_mat)
colnames(otu_mat)


otu_mat <- otu_mat %>%
  tibble::column_to_rownames("otu") 
otu_mat
tax_mat <- tax_mat %>% 
  tibble::column_to_rownames("otu")
tax_mat

samples_df <- samples_df %>% 
  tibble::column_to_rownames("sample") 

otu_mat <- as.matrix(otu_mat)
tax_mat <- as.matrix(tax_mat)
tax_mat
OTU = otu_table(otu_mat, taxa_are_rows = TRUE)
#TAX = tax_table(tax_mat)
TAX = phyloseq::tax_table(tax_mat)
samples = sample_data(samples_df)

#Transform to phyloseq objects

dx <- phyloseq(OTU, TAX, samples)
dx
TAX
sample_names(dx)
rank_names(dx)
sample_variables(dx)

OTU
TAX 
samples


library(phyloseq)
suppressPackageStartupMessages(library(microViz))



xx<-dx %>% tax_filter(min_prevalence = 80 / 100, verbose = FALSE)
xx
yd<-otu_table(xx)
write.csv(yd, "outwith80%data_EthioISR_asthmaControl.csv")
#








# Dirichlet Multinomial Mixtures
#Leo Lahti, Sudarshan Shetty et al.
#Community typing with Dirichlet Multinomial Mixtures

library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
#data(dietswap)
#pseq <- dietswap
#pseq
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp2 <- microbiome::transform(dx, "compositional")
taxa2 <- core_members(pseq.comp2, detection = 0.1/100, prevalence = 80/100)
pseq <- prune_taxa(taxa2, dx)
pseq.comp2
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(dx)
count <- as.matrix(t(dat))

fit <- lapply(1:3, dmn, count = count, verbose=TRUE)

#Check model fit with different number of mixture components using standard information criteria

lplc <- base::sapply(fit, DirichletMultinomial::laplace) # AIC / BIC / Laplace
aic  <- base::sapply(fit, DirichletMultinomial::AIC) # AIC / BIC / Laplace
bic  <- base::sapply(fit, DirichletMultinomial::BIC) # AIC / BIC / Laplace
plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
lines(aic, type="b", lty = 2)
lines(bic, type="b", lty = 3)

#Pick the optimal model

best <- fit[[which.min(unlist(lplc))]]
#Mixture parameters pi and theta
mixturewt(best)
#Sample-component assignments
ass <- apply(mixture(best), 1, which.max)
# Contribution of each taxonomic group to each component
for (k in seq(ncol(fitted(best)))) {
  d <- melt(fitted(best))
  colnames(d) <- c("OTU", "cluster", "value")
  d <- subset(d, cluster == k) %>%
    # Arrange OTUs by assignment strength
    arrange(value) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
    # Only show the most important drivers
    filter(abs(value) > quantile(abs(value), 0.8))     
  
  p <- ggplot(d, aes(x = OTU, y = value)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(title = paste("Top drivers: community type", k))
  print(p)
}





# normalization

total = median(sample_sums(dx))
dx2 = function(x, t=total) round(t * (x / sum(x)))
dx3 = transform_sample_counts(dx, dx2)
dx



dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "class") %>%
  dist_calc(dist = "bray") %>%
  ord_calc(method = "PCoA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Group") +
  theme_classic(12) +
  coord_fixed(0.7) +
  stat_ellipse(aes(color = Group)) +
  scale_color_brewer(palette = "Set1")



dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "class") %>%
  dist_calc(dist = "bray") %>%
  ord_calc(method = "PCoA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Race") +
  theme_classic(12) +
  coord_fixed(0.7) +
  stat_ellipse(aes(color = Race)) +
  scale_color_brewer(palette = "Set1")



dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "class") %>%
  dist_calc(dist = "bray") %>%
  ord_calc(method = "PCoA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Gender") +
  theme_classic(12) +
  coord_fixed(0.7) +
  stat_ellipse(aes(color = Gender)) +
  scale_color_brewer(palette = "Set1")



dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "class") %>%
  dist_calc(dist = "bray") %>%
  ord_calc(method = "PCoA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Group") +
  theme_classic(12) +
  coord_fixed(0.7) +
  stat_ellipse(aes(color = Group)) +
  scale_color_brewer(palette = "Set1")



dx %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "Species") %>%
  dist_calc(dist = "bray") %>%
  dist_permanova(variables = "Type", n_perms = 99, seed = 123) %>%
  perm_get()

# Covariate-adjusted PERMANOVA

dx %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "Species") %>%
  dist_calc(dist = "bray") %>%
  dist_permanova(
    variables = c("Type", "Gender", "Age"),
    n_perms = 99, seed = 111
  ) %>%
  perm_get()

#Log transformations, and CLR

dx %>%
  tax_sort(by = sum, at = "Species", trans = "compositional", tree_warn = FALSE) %>%
  tax_transform(trans = "compositional", rank = "Species") %>%
  comp_heatmap(samples = 1:20, taxa = 1:20, name = "Proportions", tax_seriation = "Identity")

#Centered Log Ratio transformation

dx %>%
  tax_sort(by = sum, at = "Species", trans = "compositional", tree_warn = FALSE) %>%
  tax_agg(rank = "Species") %>%
  tax_transform(trans = "clr", zero_replace = "halfmin", chain = TRUE) %>%
  comp_heatmap(
    samples = 1:20, taxa = 1:20, grid_lwd = 2, name = "CLR",
    colors = heat_palette(sym = TRUE),
    tax_seriation = "Identity"
  )

#PCA on CLR-transformed taxa
dx %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_transform(rank = "Species", trans = "clr", zero_replace = "halfmin") %>%
  ord_calc(method = "PCA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Asthma") +
  theme_classic(12) +
  coord_fixed(0.7)

#Taxon stats

dx %>%
  comp_barplot(
    tax_level = "Species", n_taxa = 12, facet_by = "Immigrant_status",
    label = NULL, bar_outline_colour = NA
  ) +
  coord_flip() +
  theme(axis.ticks.y = element_blank())


#EthioISR_Asthmatic
OTU
TAX 
samples



dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "Species") %>%
  dist_calc(dist = "bray") %>%
  ord_calc(method = "PCoA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Group_Type") +
  theme_classic(12) +
  coord_fixed(0.7) +
  stat_ellipse(aes(color = Group_Type)) +
  scale_color_brewer(palette = "Set1")

dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "Species") %>%
  dist_calc(dist = "bray") %>%
  dist_permanova(variables = "Group_Type", n_perms = 99, seed = 123) %>%
  perm_get()

#Covariate-adjusted PERMANOVA

dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_agg(rank = "Species") %>%
  dist_calc(dist = "bray") %>%
  dist_permanova(
    variables = c("Group_Type", "Gender", "Age"),
    n_perms = 99, seed = 111
  ) %>%
  perm_get()

xx<-dx3 %>% tax_filter(min_prevalence = 80 / 100, verbose = FALSE)
xx
yd<-otu_table(xx)

write.csv(yd, "asthmaticprevalence_80%andmore.csv")


#Log transformations, and CLR

dx3 %>%
  tax_sort(by = sum, at = "Species", trans = "compositional", tree_warn = FALSE) %>%
  tax_transform(trans = "compositional", rank = "Species") %>%
  comp_heatmap(samples = 1:6, taxa = 1:20, name = "Proportions", tax_seriation = "Identity")

#Centered Log Ratio transformation

dx3 %>%
  tax_sort(by = sum, at = "Species", trans = "compositional", tree_warn = FALSE) %>%
  tax_agg(rank = "Species") %>%
  tax_transform(trans = "clr", zero_replace = "halfmin", chain = TRUE) %>%
  comp_heatmap(
    samples = 1:16, taxa = 1:20, grid_lwd = 2, name = "CLR",
    colors = heat_palette(sym = TRUE),
    tax_seriation = "Identity"
  )

#PCA on CLR-transformed taxa
dx3 %>%
  tax_filter(min_prevalence = 2.5 / 100, verbose = FALSE) %>%
  tax_transform(rank = "class", trans = "clr", zero_replace = "halfmin") %>%
  ord_calc(method = "PCA") %>%
  ord_plot(alpha = 0.6, size = 2, color = "Group") +
  theme_classic(12) +
  coord_fixed(0.7)




#Taxon stats

# Transform to compositional abundances
dx.rel <- microbiome::transform(dx, "compositional")

# Pick the core (>0.1% relative abundance in >50% of the samples)
dx.core <- core(dx.rel, detection = 0.1/100, prevalence = 50/100)

sampl

tiff("Group_AR2.pdf", units="in", width=5, height=5, res=300)


png("Group_AR2x.png", width=10, height=5, units="in", res=300)


dx%>%
  comp_barplot(
    tax_level = "Species", n_taxa = 20, facet_by = "Group",
    label = NULL, bar_outline_colour = NA
  ) +
  coord_flip() +
  theme(axis.ticks.y = element_blank())


dev.off()


pdf("pic_ETH_asthmacontrol_x2x.pdf", width=10, height=6)
dx%>%
  comp_barplot(
    tax_level = "Species", n_taxa = 20, facet_by = "",
    label = NULL, bar_outline_colour = "darkgrey"
  ) +
  coord_flip() +
  theme(axis.ticks.y = element_blank())

dev.off()
dx

pdf("pic_ETHISR_control_x22.pdf", width=10, height=6)
dx %>%
  comp_barplot(
    tax_level = "Species", n_taxa = 30, other_name = "Other",
    taxon_renamer = function(x) stringr::str_remove(x, " [ae]t rel."),
    palette = distinct_palette(n = 30, add = "grey90"),
    merge_other = FALSE, bar_outline_colour = "darkgrey"
  ) +
  coord_flip() +
  facet_wrap("Group", nrow = 1, scales = "free") +
  labs(x = NULL, y = NULL) +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
dev.off()
dx



#Example ordination plot workflow
# perform ordination
unconstrained_aitchison_pca <- dx %>%
  tax_filter(min_prevalence = 0.1, tax_level = "Species") %>%
  tax_agg("Family") %>%
  tax_transform("clr") %>%
  ord_calc()
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.
# ord_calc will automatically infer you want a "PCA" here
# specify explicitly with method = "PCA", or you can pick another method

# create plot
pca_plot <- unconstrained_aitchison_pca %>%
  ord_plot(
    plot_taxa = 1:6, colour = "bmi_group", size = 1.5,
    tax_vec_length = 0.325,
    tax_lab_style = tax_lab_style(max_angle = 90, aspect_ratio = 0.5),
    auto_caption = 8
  )

# customise plot
customised_plot <- pca_plot +
  stat_ellipse(aes(linetype = bmi_group, colour = bmi_group), linewidth = 0.3) + # linewidth not size, since ggplot 3.4.0
  scale_colour_brewer(palette = "Set1") +
  theme(legend.position = "bottom") +
  coord_fixed(ratio = 0.5, clip = "off") # makes rotated labels align correctly
# show plot
customised_plot

#Alpha diversity#Global indicators
tab <-microbiome::alpha(dx3, index = "all")
tab
write.csv(tab, "ISR_asthmaticcontrol_Alpha diversity_Global2_sp.csv")

#richness
tab <- richness(dx)
tab
samples
p.shannon <- boxplot_alpha(dx3, 
                           index = "shannon",
                           x_var = "Subgroup",
                           fill.colors = C("red", "blue", "green"))

p.shannon <- p.shannon + theme_minimal() + 
  labs(x="Subgroup", y="Shannon diversity") +
  theme(axis.text = element_text(size=12),
        axis.title = element_text(size=16),
        legend.text = element_text(size=12),
        legend.title = element_text(size=16))
p.shannon
dx



library(ggpubr)
d<-read.csv("Alpha diversity_Global2.csv", row.names = 1)
d<-read.csv("ISR_asthmaticcontrol_Alpha diversity_Global2_sp.csv", row.names = 1, check.names = FALSE)
d<-read.csv("Ethio_asthmaticcontrol_Alpha diversity_Global2_sp.csv", row.names = 1, check.names = FALSE)
d<-read.csv("EthioISR_asthmaticcontrol_Alpha diversity_Global2_sp.csv", row.names = 1, check.names = FALSE)
d<-read.csv("EthioISR_asthmatic_Alpha diversity_Global2_sp.csv", row.names = 1, check.names = FALSE)


d<-read.csv("Ethio_asthmaticcontrol_Alpha diversity_Global2_sp_chao1x_shanonRemoveoutlier.csv", row.names = 1, check.names = FALSE)
d<-read.csv("Ethio_asthmaticcontrol_Alpha diversity_Global2_sp_chao_outlierRemoved.csv", row.names = 1, check.names = FALSE)
d<-read.csv("ISR_asthmaticcontrol_Alpha diversity_Global2_sp_shanondiversity_outlierRemoved.csv", row.names = 1, check.names = FALSE)
d<-read.csv("ISR_asthmaticcontrol_Alpha diversity_Global2_sp_chao_outremoved.csv", row.names = 1, check.names = FALSE)
d<-read.csv("EthioISR_asthmaticcontrol_Alpha diversity_Global2_sp_shanonOutRemoved.csv", row.names = 1, check.names = FALSE)
d<-read.csv("EthioISR_asthmaticcontrol_Alpha diversity_Global2_sp_chaoRemoved.csv", row.names = 1, check.names = FALSE)

#("ETH+ISR-asthmatic" = "#FC4E07", "ETH+ISR-control" = "#00AFBB"))

d$Group
samples
head(d)
d$Group
summary(d$Chao1)
summary(d$`Shannon diversity`)
# add boxplot with white fill color
my_comparisons <- list( c("ETH-asthmatic", "ETH-control" ))

#tiff("Group_specieShannon.tiff", units="in", width=5, height=5, res=500)

ggviolin(d, x = "Group", y = "Shannon diversity", fill = "Group",
         palette = c("#FC4E07", "#00AFBB"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y =6)    

d$diversity_shannon

# Decide the order of groups in the argument levels
d$Group <- factor(d$Group, levels = c("ISR-asthmatic", "ISR-control"))


#Adjust appearance
scale_fill_manual(values   = c("ISR-asthmatic" = "#FC4E07", "ISR-control" = "#00AFBB")) 

ggplot(pca, aes(d       = PC1, 
                y       = PC2, 
                fill    = Group,
                colour  = Group,
                shape   = Group,
                group   = Group)) +  
  
  #Create the points
  stat_ellipse(geom = "polygon", alpha = 1/4) +
  geom_point(size=2, col = "black")  

betad 

d$Chao1
d$Group
d$Group<-as.factor(d$Group)
p <- ggboxplot(d, x = "Group", y = "Shannon diversity",
               color = "Group", palette = c("#FC4E07", "#00AFBB"),
               add = "jitter")
#  Add p-value
p + stat_compare_means()
# Change method
p + stat_compare_means(method = "")




d$Group<-as.factor(d$Group)
p <- ggboxplot(d, x = "Group", y = "Chao1",
               color = "Group", palette = c("#FC4E07", "#00AFBB"),
               add = "jitter")
#  Add p-value
p + stat_compare_means()
# Change method
p + stat_compare_means(method = "")


#t.test

my_comparisons <- list( c("ETH+ISR-asthmatic", "ETH+ISR-asthmatic"))

# add boxplot with white fill color
ggviolin(d, x = "Group", y = "Chao1", fill = "Group",
         palette = c("#FC4E07", "#00AFBB"),
         add = " ", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y = 4000)             


library(ggpubr)
library(rstatix)
summary(d$diversity_shannon)
d$Group
attach(d)


# Statistical test
stat.test <- d %>%
  t_test(d$Chao1 ~ Group) %>%
  add_significance()
stat.test
d$diversity_gini_simpson
# Box plots with p-values
bxp <- ggboxplot(d, x = "Group", y = "Chao1", fill = "#00AFBB")
stat.test <- stat.test %>% add_xy_position(x = "Group")
bxp + 
  stat_pvalue_manual(stat.test, label = "p") +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1)))

#ggplot2

d<-read.csv("EthioISR_asthmatic_Alpha diversity_Global2_species_normalized2.csv", row.names =1)
compare_means(Shannon.diversity ~ Groupx,  data = d,
              ref.group = ".all.", method = "t.test")


# Visualize the expression profile
ggboxplot(d, x = "Groupx", y = "Shannon.diversity", color = "Groupx", 
          add = "jitter", legend = "none") +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(d$Shannon.diversity), linetype = 2)+ # Add horizontal line at base mean
  stat_compare_means(method = "anova", label.y = 6)+        # Add global annova p-value
  stat_compare_means(label = "p.signif", method = "t.test",
                     ref.group = ".all.")      


# Visualize the expression profile

pdf("shanon_diversity_group4.pdf", width=4, height=4)

ggboxplot(d, x = "Group", y = "Shannon diversity", color = "Group", 
          add = "jitter", legend = "none", xlab = " ", ylab = "Shannon diversity") +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(d$Shannon.diversity), linetype = 2)+ # Add horizontal line at base mean
  stat_compare_means(method = "anova", label.y = 6)+        # Add global annova p-value
  stat_compare_means(label = "p.signif", method = "t.test",
                     ref.group = ".all.", hide.ns = TRUE)      # Pairwise comparison against all

dev.off()

#chao1 diversity

compare_means(Chao1 ~ Groupx,  data = d,
              ref.group = ".all.", method = "t.test")


# Visualize the expression profile
ggboxplot(d, x = "Groupx", y = "Chao1", color = "Groupx", 
          add = "jitter", legend = "none") +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(d$Shannon.diversity), linetype = 2)+ # Add horizontal line at base mean
  stat_compare_means(method = "anova", label.y = 6)+        # Add global annova p-value
  stat_compare_means(label = "p.signif", method = "t.test",
                     ref.group = ".all.")      




# Visualize the expression profile

pdf("Chao1_group1.pdf", width=4, height=4)

ggboxplot(d, x = "Groupx", y = "Chao1", color = "Groupx", 
          add = "jitter", legend = "none", xlab = " ", ylab = "Chao1") +
  rotate_x_text(angle = 45)+
  geom_hline(yintercept = mean(d$Chao1), linetype = 2)+ # Add horizontal line at base mean
  stat_compare_means(method = "anova", label.y = 3000)+        # Add global annova p-value
  stat_compare_means(label = "p.signif", method = "t.test",
                     ref.group = ".all.", hide.ns = TRUE)      # Pairwise comparison against all

dev.off()


# vegan
library(factoextra)
library(FactoMineR)

library(vegan)
dx<-read.csv("OTU_PCA.csv", row.names = 1, check.names = FALSE)
dim(dx)
dx1<-dx[,-5929]
# Hellinger transformation

spc.dx1 <- decostand(dx1, method = "total")
spc.dx1[1:5, 1:6]
res.pca <- PCA(spc.dx1, graph = FALSE)
eig.val <- get_eigenvalue(res.pca)
eig.val
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))
var <- get_pca_var(res.pca)
var
var.sp<-get_pca_var(res.pca)
var.sp
head(var.sp$contrib)




library(corrplot)
#corrplot(var$contrib, is.corr=FALSE)

biplot(prin_comp, choices = 3:4,scale = 0)  
# to plot the third and fourth components




fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 10)


var.sp<-get_pca_var(res.pca)
var.sp
head(var.sp$contrib)

fviz_pca_biplot(res.pca, 
                col.ind = dx$Group, palette = "jco",
                select.var= list(name = c ("Bifidobacterium catenulatum", "Bifidobacterium kashiwanohense", "Bifidobacterium pseudocatenulatum", "Bifidobacterium pseudocatenulatum", "Bifidobacterium adolescentis")),
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Group")




fviz_pca_biplot(res.pca, 
                # Individuals
                geom.ind = "point",
                fill.ind = dx$Group, col.ind = "black",
                pointshape = 18, pointsize = 1,
                palette = "jco",
                addEllipses = TRUE,
                
                # Variables
                alpha.var ="contrib", col.var = "contrib",
                gradient.cols = "RdYlBu",
                
                legend.title = list(fill = "Group", color = "Contrib",
                                    alpha = "Contrib")
)

                
                
# invisible ="var",       
            

fviz_pca_biplot(res.pca, 
                # Individuals
                geom.ind = "point",
                fill.ind = dx$Group, col.ind = "black",
                pointshape = 21, pointsize = 2,
                palette = "jco",
                addEllipses = TRUE,
                select.var= list(name = c("Bifidobacterium catenulatum", "Bifidobacterium kashiwanohense")),
                # Variables
                alpha.var ="contrib", col.var = "contrib",
                gradient.cols = "RdYlBu",
                legend.title = list(fill = "Group", color = "Contrib",
                                    alpha = "Contrib")
)


biplot(prin_comp, choices = 3:4,scale = 0)








#FC4E07
#00AFBB
#dev.off()

d$Asthma_status
my_comparisons <- list( c("Asthmatic", "Control"))

#tiff("Group_specieShannon.tiff", units="in", width=5, height=5, res=500)

ggviolin(d, x = "Asthma_status", y = "Shannon", fill = "Asthma_status",
         palette = c("#FC4E07", "#00AFBB"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y =10)  



ggviolin(d, x = "Asthma_status", y = "chao1", fill = "Asthma_status",
         palette = c("#FC4E07", "#00AFBB"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y =4000)  



library(ggplot2)
library(MicrobiotaProcess)
library(tidyverse)
library(seriation)
library(phyloseq)
library(microViz)
library(shiny)



#removing species not seen > 10% of samples
dxr <- filter_taxa(dx, function(x) sum(x > 0) > (0.05*length(x)), TRUE)   
head(sort(sample_sums(dxr))) 
sample_variables(dxr)

#sample_data(dxr)$d <- factor(sample_data(ps)$location, levels = c("A", "C"))
table(sample_data(dxr)$Asthma) 
sample_data(dxr)$Asthma
dds <- phyloseq_to_deseq2(dxr, ~ Asthma)  
ddx <- as.DGEList(dds)
ddx2 <- calcNormFactors(ddx, method = "TMM")           #store TMM norm factor
head(ddx2$samples$norm.factors)
mm <- model.matrix(~ group, ddx2$samples)              #construct model matrix          
head(mm)
table(mm[, 2])
y <- voom(ddx2, mm, plot = T)   #obtain Voom weights

fit <- lmFit(y, mm)                                   #fit lm with limma
fit <- eBayes(fit)
head(coef(fit))

limma_res_df <- data.frame(topTable(fit, coef = "groupC", number = Inf))    #extract results

fdr_limma <- limma_res_df %>%
  dplyr::filter(P.Value < 0.05) %>%
  rownames_to_column(var = "Species")  #adj.P.Val

dim(fdr_limma)

head(fdr_limma)

#Corncob
corn_da <- differentialTest(formula = ~ Asthma,
                            phi.formula = ~ 1,
                            formula_null = ~ 1,
                            phi.formula_null = ~ 1,
                            data = dx,
                            test = "Wald", boot = FALSE,
                            fdr_cutoff = 0.1)

fdr_corncob <- corn_da$significant_taxa
dim(data.frame(fdr_corncob))
fdr_corncob

#MaAsLin 2

mas_1 <- Maaslin2(
  input_data = data.frame(otu_table(dxr)),
  input_metadata = data.frame(sample_data(dxr)),
  output = "C:/Users/desqz2/Desktop/Abundence_Table/Species/sp/ma",
  min_abundance = 0.0,
  min_prevalence = 0.0,
  normalization = "TSS",
  transform = "LOG",
  analysis_method = "LM",
  max_significance = 0.05,
  fixed_effects = "Asthma",
  correction = "BH",
  standardize = FALSE,
  cores = 1)

mas_res_df <- mas_1$results

fdr_mas <- mas_res_df %>%
  dplyr::filter(qval < 0.05)

dim(fdr_mas)
library(tidyverse)
library(vegan)
library(corncob)
library(phyloseq)
library(microbiome)
library(ComplexHeatmap)
library(vctrs)
library(ggplot2)
#?corncob
library(ggtext)
library(ggraph)
library(DT)
library(phyloseq)
library(dplyr)
library(ggplot2)
library(Maaslin2)

inputData<-read.csv("Tes_genus_abundance_allData.kraken_assigned_reads2x_normalized_desqz20xx.csv", row.names = 1)
inputData<-read.csv("Tes_genus_abundance_allData.kraken_assigned_reads2xcount.csv", row.names = 1)

inputmeta<-read.csv("Design_genus_abundentx2.csv", row.names = 1)
inputmeta
inputmeta$Group_Type
  
fit_datax <- Maaslin2(
  inputData, inputmeta,'1Asthma_abundentx1',
  fixed_effects = c('Type', 'Allergic.Rhinitis', 'Group_Type'),
  random_effects = 'NONE',
  normalization = 'NONE',
  reference = c('Group', 'Control'),
  standardize = FALSE)


fit_datax <- Maaslin2(
  inputData, inputmeta,'2Asthma_abundent3',
  fixed_effects = c('Group', 'AR_status' ),
  random_effects = 'NONE',
  normalization = "TSS",
  reference = 'NONE',
  standardize = FALSE)


#specious data
inputData<-read.csv("Tes_species_abundance_allData.kraken_assigned_reads2_desqz20.75x2.csv", row.names = 1)
inputData<-read.csv("Tes_species_abundance_allData.kraken_assigned_reads2_desqz20.75x2.csv", row.names = 1)



inputmeta<-read.csv("Design_genus_abundentx2.csv", row.names = 1)
inputmeta
inputmeta
head(inputmeta)

  fit_datax <- Maaslin2(
    inputData, inputmeta,'Asthma_specious_abundentx12',
    fixed_effects = c('Group' ),
    random_effects = 'NONE',
    normalization = 'NONE',
    reference = c('Group', 'Control'),
    standardize = FALSE)

fit_datax <- Maaslin2(
  inputData, inputmeta,'Asthma_species_abundance.Maaslin2x',
  fixed_effects = c('Group','Age'),
  random_effects = 'NONE',
  normalization = 'NONE',
  reference = 'NONE',
  standardize = FALSE)

fit_datax <- Maaslin2(
  inputData, inputmeta,'Asthma_species_abundance.Maaslin2x2',
  fixed_effects = NULL,
  random_effects = NULL,
  normalization = 'NONE',
  reference = NULL,
  standardize = TRUE)



?Maaslin2

library(rpart)
library(tidyverse)
getwd()
df<-read.csv("dfx2.csv")
df$s
df$coef
df2 <- df %>% 
  tibble::rownames_to_column() %>% 
  dplyr::rename("variable" = rowname) %>% 
  dplyr::arrange(coef) %>%
  dplyr::mutate(variable = forcats::fct_inorder(feature))
ggplot2::ggplot(df2) +
  geom_col(aes(x = feature, y = coef),
           col = "black", show.legend = F) +
  coord_flip() +
  scale_fill_grey() +
  theme_bw()
# Heatmapbased metadata
ggplot2::ggplot(df2) +
  geom_segment(aes(x = feature, y = 0, xend = feature, yend = coef), 
               size = 1.5, alpha = 0.7) +
  geom_point(aes(x = feature, y = coef, col = metadata), 
             size = 4, show.legend = T) +
  coord_flip() +
  theme_bw()

#heatmap based coefficient
ggplot2::ggplot(df2) +
  geom_segment(aes(x = feature, y = 0, xend = feature, yend = coef), 
               size = 1, alpha = 2) +
  geom_point(aes(x = feature, y = coef, col = coef), 
             size = , show.legend = T) +
  coord_flip() + 
  theme_bw()  + scale_colour_gradientn(colours=rainbow(4))

#heatmap based coefficient
ggplot2::ggplot(df2) +
  geom_segment(aes(x = feature, y = 0, xend = feature, yend = coef), 
               size = 1, alpha = 2) +
  geom_point(aes(x = feature, y = coef, col = coef), 
          size = 4,   show.legend = T) + 
  coord_flip() + 
  theme_bw() + scale_colour_gradientn(colours=rainbow(6))



tiff("test.tiff", units="in", width=5, height=5, res=300)
ggplot2::ggplot(df2) +
  geom_segment(aes(x = feature, y = 0, xend = feature, yend = coef), 
               size = 1, alpha = 2) +
  geom_point(aes(x = feature, y = coef, col = coef), 
             size = 4,   show.legend = T) + ylab(" Importance")+ xlab("Features")+
  coord_flip() + 
  theme_bw() + scale_colour_gradientn(colours=rainbow(2))


tiff("test.tiff", units="in", width=5, height=5, res=300)
dev.off()
# Read the data and create phyloseq objects
rm(list = ls())

library(lefser)
require(dplyr)
require(tibble)
library(qiime2R)
library(circlize)
library(ggplot2)
library(microbiomeMarker)
library(RColorBrewer)
library(ggthemr)
library(plyr)
library(phyloseq)
library(tidyverse)
library(ComplexHeatmap)
library(cowplot)
library(corncob)
library(phyloseq)
library(ggplot2)      # graphics
library(readxl)       # necessary to import the data from Excel file
library(dplyr)        # filter and reformat data frames
library(tibble)       # Needed for converting column to row names


#genus
otu_mat<- read_excel("OTU_genus_abundance_allData.kraken_assigned_reads2xcountData.xlsx")
tax_mat<- read_excel("Taxonomy_genus_abundent.xlsx")
samples_df <- read_excel("Sample_genus_abundentData23.xlsx")


#species
otu_mat<- read_excel("OTU_species_abundance_allData.kraken_assigned_reads2.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent.xlsx")
samples_df <- read_excel("Sample_species_abundentData2.xlsx")
getwd()

#normalized analysis 
#species
otu_mat<- read_excel("Tes_species_abundance_allData.kraken_assigned_reads2_desqNormalized.xlsx")
tax_mat<- read_excel("Taxonomy_species_abundent_desqNormalized.xlsx")
samples_df <- read_excel("Sample_genus_abundentData2.xlsx")
getwd()

otu_mat<- read_excel("OTU_species_abundance_SP_DAACountdatax.xlsx")
#otu_mat<- read_excel("OTU_species_abundance_SP_DAACountdatax_EN.xlsx")
#otu_mat<- read_excel("OTU_species_abundance_SP_DAA.xlsx") not working for normalized data
tax_mat<- read_excel("Taxonomy_species_abundent_DAA.xlsx",)
samples_df <- read_excel("Sample_species_abundentData23.xlsx")
getwd()
samples_df
dim(samples_df)
dim(tax_mat)
dim(otu_mat)
tax_mat

class(otu_mat)



otu_mat <- otu_mat %>%
  tibble::column_to_rownames("otu") 
otu_mat
tax_mat <- tax_mat %>% 
  tibble::column_to_rownames("otu")

samples_df <- samples_df %>% 
  tibble::column_to_rownames("sample") 

otu_mat <- as.matrix(otu_mat)
tax_mat <- as.matrix(tax_mat)

OTU = otu_table(otu_mat, taxa_are_rows = TRUE)
TAX = tax_table(tax_mat)
samples = sample_data(samples_df)

#Transform to phyloseq objects
dx <- phyloseq(OTU, TAX, samples)
dx

sample_names(dx)
rank_names(dx)
sample_variables(dx)

OTU
samples



#Microbiome Diversity
library(microbiome)
library(phyloseq)
library(ggplot2)
library(kableExtra)


total = median(sample_sums(dx))
dx2 = function(x, t=total) round(t * (x / sum(x)))
dx3 = transform_sample_counts(dx, dx2)

#Sample ordination
# Ordinate the data
set.seed(42)
# proj <- get_ordination(pseq, "MDS", "bray")
ord <- ordinate(dx3, "MDS", "bray")
plot_ordination(dx3, ord, color = "Type") +
  geom_point(size = 5)
ord$values

dx

samples
Group_Type
#Canonical correspondence analysis (CCA)

# With samples
dx3.cca <- ordinate(dx3, "CCA")

#tiff("Group_speciesx23.tiff", units="in", width=5, height=5, res=500)
p <- plot_ordination(dx, dx3.cca,
                     type = "sample", color = "Asthma")
p <- p + geom_point(size = 4)
#dev.off()
print(p)
# With taxa:
# Data normalisation


p <- plot_ordination(dx, dx3.cca,
                     type = "class", color = "Immigrant_status")
p <- p + geom_point(size = 4)
print(p)





Immigrant_statu

# add boxplot with white fill color
my_comparisons <- list( c("Immigrant", "Nonimmigrant"))
#tiff("Group_speciesSimpson.tiff", units="in", width=5, height=5, res=500)
ggviolin(d, x = "Immigrant_status", y = "Simpson", fill = "Immigrant_status",
         palette = c("#00AFBB", "#FC4E07"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y =100)    
#dev.off()
d$Gender
my_comparisons <- list( c("Male", "Female"))
#tiff("Group_speciesSimpson.tiff", units="in", width=5, height=5, res=500)
ggviolin(d, x = "Gender", y = "chao1", fill = "Gender",
         palette = c("#FC4E07", "#00AFBB"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y =100)    
#dev.off()






dx3
d$Age
x6<-ggscatter(d, x = "Age", y = "chao1", 
              add = "reg.line", conf.int = TRUE,
              add.params = list(fill = "blue"),
              cor.coef = TRUE, cor.method = "pearson",
              xlab = "Age(years)", ylab = "chao1") + ggtitle("")
x6

x7<-ggscatter(d, x = "Age", y = "Shannon", 
              add = "reg.line", conf.int = TRUE,
              add.params = list(fill = "blue"),
              cor.coef = TRUE, cor.method = "pearson",
              xlab = "Age(years)", ylab = "Simpson") + ggtitle("")
x7





#beta diversity

OTU = otu_table(otu_mat, taxa_are_rows = TRUE)
TAX = tax_table(tax_mat)
samples = sample_data(samples_df)
samples

#Transform to phyloseq objects
dx <- phyloseq(OTU, TAX, samples)
dx

set.seed(111) # keep result reproductive
dx2= rarefy_even_depth(dx, rngseed=1, sample.size=1103, replace=F)


#Alpha diversity

plot_richness(dx2, x="Immigrant_status", measures=c("Observed", "Shannon")) +
  geom_boxplot() +
  theme_classic() +
  theme(strip.background = element_blank(), axis.text.x.bottom = element_text(angle = -90))





rich = estimate_richness(ps.rarefied, measures = c("Observed", "Shannon"))
wilcox.observed <- pairwise.wilcox.test(rich$Observed, 
                                        sample_data(ps.rarefied)$body.site, 
                                        p.adjust.method = "BH")
tab.observed <- wilcox.observed$p.value %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "group1") %>%
  gather(key="group2", value="p.adj", -group1) %>%
  na.omit()
tab.observed


sample_names(dx)
rank_names(dx)
sample_variables(dx)
BC.nmds = metaMDS(OTU, distance="bray", k=2, trymax=1000)
BC.nmds


# Construct the data
d <- meta(dx)
d$diversity <- microbiome::diversity(dx, "shannon")$shannon
d$diversity

# Split the values by group
spl <- split(d$diversity, d$Group_Type)
# Kolmogorov-Smironv test
pv <- ks.test(spl$Ethio, spl$ISR)$p.value
#t-test
t.test(spl$Ethio, spl$ISR)$p.value
shapiro.test(spl$Ethio, spl$ISR)$p.value


# Adjust the p-value
padj <- p.adjust(pv)
padj
pv

#beta diversity 
#Bray curtis


dist = phyloseq::distance(dx3, method="bray")
ordination = ordinate(dx3, method="PCoA", distance=dist)
plot_ordination(dx3, ordination, color="Type") + 
  theme_classic() +
  theme(strip.background = element_blank())

dist
dx3
samples_df

#PERMANOVA/ADONIS
library(phyloseq)
library(tidyverse)
library(vegan)
library(DESeq2)
library(ANCOMBC)
library(ComplexHeatmap)


library(phyloseq)
library(ggplot2)
library(dplyr)
library(ggpubr)
library(Matrix)
library(reshape2)
library(vegan)



dx3
metadata <- data.frame(sample_data(dx3))

test.adonis <- adonis2(dist ~ Type, data = metadata)
test.adonis <- as.data.frame(test.adonis$aov.tab)
test.adonis

dx.sp = transform_sample_counts(dx, function(x) x / sum(x) * 100) 

head(otu_table(dx.sp)[,1:6])
#Calculate Bray-Curtis distance among samples
sp_bray <- phyloseq::distance(dx.sp, method = "bray")
sp_bray <- as.matrix(sp_bray)
head(sp_bray)[,1:6]
sp_bray


sub_dist <- list()
groups_all <- sample_data(dx.sp)$Groupx

for (group in levels(groups_all)) { 
  row_group <- which(groups_all == group)
  sample_group <- sample_names(dx.sp)[row_group]
  sub_dist[[group]] <- abrel_bray[ sample_group, sample_group]
  sub_dist[[group]][!lower.tri(sub_dist[[group]])] <- NA
}

braygroups<- melt(sub_dist)
df.bray <- braygroups[complete.cases(braygroups), ]
df.bray$L1 <- factor(df.bray$L1, levels=names(sub_dist))

head(df.bray)


sample_data(dx.sp)
head(df.bray)
groups_all
groups_all
sub_dist
sub_dist






head(df.bray)
sample_names(dx.sp)
samples_df
sample_data(dx.sp)
sample












install.packages("remotes")
remotes::install_github("umerijaz/microbiomeSeq")
install.packages("remotes")
remotes::install_github("biobakery/SparseDOSSA2")
library(SparseDOSSA2)
?SparseDOSSA2






















#plot_bar(dx, fill = "class")

#Network analysis

plot_net(dx, distance = "(A+B-2*J)/(A+B)", type = "taxa", 
         maxdist = 0.7, color="class", point_label="class")



# Beta binomial regression

library(corncob)
library(corncob)
library(phyloseq)
library(magrittr)
?corncob


#Fitting a Model
corncob <- bbdml(formula = otu01  ~ 1,
                 phi.formula = ~ 1,
                 data = dx)

plot(corncob, B = 50)
plot(corncob, total = TRUE, B = 50)
plot(corncob, total = TRUE, color = "Asthma", B = 50)
#Adding covariates
corncob_da <- bbdml(formula = otu01 ~ Group,
                    phi.formula = ~ Group,
                    data = dx)

plot(corncob_da, color = "Group", total = TRUE, B = 50)
plot(corncob_da, color = "Group", B = 50)
#Model Selection
lrtest(mod_null = corncob, mod = corncob_da)
#Parameter Interpretation
summary(corncob_da)
#Analysis for Multiple Taxa
set.seed(1)

#run corncob to test for differences in relative abundance,
#adjusting for geneder category and age on abundance and age,
#Gender, and Asthma on variability
d <- differentialTest(formula = ~Asthma + Gender  + Group_Type,
                      formula_null = ~ Gender + Group_Type,
                      phi.formula = ~ 1,
                      phi.formula_null = ~1,
                      data = dx,
                      test = "Wald", boot = FALSE,
                      fdr_cutoff = .05)

plot(d, level="class")

d <- differentialTest(formula = ~Asthma + Gender + Age + Group_Type,
                      phi.formula = ~ Gender + Age + Group_Type,
                      formula_null = ~ Gender + Age,
                      phi.formula_null = ~ Gender + Age + Group_Type,
                      data = dx,
                      test = "Wald", boot = FALSE,
                      fdr_cutoff = .005)

plot(d, level="Species")


d <- differentialTest(formula = ~Asthma + Immigrant_status ,
                      phi.formula = ~ 1,
                      formula_null = ~ Immigrant_status,
                      phi.formula_null = ~ 1,
                      data = dx,
                      test = "Wald", boot = FALSE,
                      fdr_cutoff = .005)

plot(d, level="Species")




samples

sig_marker_corncob<-as.data.frame(otu_to_taxonomy(OTU = d$significant_taxa, data = dx))
sig_marker_corncob

lefse_cc_path_fam <- run_lefse(
  dx,
  wilcoxon_cutoff = 0.05,
  group = "AsthmaC",
  kw_cutoff = 0.05,
  multigrp_strat = TRUE,
  lda_cutoff = 0,
  taxa_rank="Species"
)
lefse_cc_path_fam





d$significant_models





plot(d, level="class")
d$significant_taxa
d$significant_models





samples$Gender
samples$Group_Type
samples$Asthma
samples$Age







da_analysis <- differentialTest(formula = ~ Asthma,
                                phi.formula = ~ Asthma,
                                formula_null = ~ 1,
                                phi.formula_null = ~ Asthma,
                                test = "Wald", boot = FALSE,
                                data = dx,
                                fdr_cutoff = 0.05)

plot(da_analysis, color = NULL)
samples


#List of differential-abundant taxa using:
da_analysis$significant_taxa

otu_to_taxonomy(OTU = da_analysis$significant_taxa, data = dx)



#list of differentially-variable taxa using:
set.seed(1)
dv_analysis <- differentialTest(formula = ~ Group,
                                phi.formula = ~ Group,
                                formula_null = ~ Group,
                                phi.formula_null = ~ 1,
                                data = dx,
                                test = "LRT", boot = FALSE,
                                fdr_cutoff = 0.05)
dv_analysis$significant_taxa
otu_to_taxonomy(OTU = da_analysis$significant_taxa, data = dx)
otu_to_taxonomy(OTU = dv_analysis$significant_taxa, data = dx)

# We can also plot the model coefficients of our results:
  plot(dv_analysis)







# a subset of the p-values of our tests using:
da_analysis$p
da_analysis$p_fdr


tiff("test2.tiff", units="in", width=5, height=5, res=300)
plot(da_analysis)
dev.off()
getwd()
#Examples of Answering Scientific Questions
ex1 <- differentialTest(formula = ~ Group,
                        phi.formula = ~ 1,
                        formula_null = ~ 1,
                        phi.formula_null = ~ 1,
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.05)
plot(ex1)


ex2 <- differentialTest(formula = ~ Group,
                        phi.formula = ~ Group,
                        formula_null = ~ 1,
                        phi.formula_null = ~ Group,
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.05)
plot(ex2)


# Jointly testing for differential abundance and differential variability across Day:

ex3 <- differentialTest(formula = ~ Group,
                          phi.formula = ~ Group,
                          formula_null = ~ 1,
                          phi.formula_null = ~ 1,
                          data = dx,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.05)
plot(ex3)


# Jointly testing for differential abundance and 
#differential variability across Group, controlling for the effect of
# Race on abundance only:
ex4 <- differentialTest(formula = ~ Group + AR_status,
                          phi.formula = ~ Group,
                          formula_null = ~ AR_status,
                          phi.formula_null = ~ 1,
                          data = dx,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.05)
plot(ex4)



# Jointly testing for differential abundance across Day and differential abundance across Amdmt, controlling
# for the effect of Day and Amdmt on dispersion:

  
ex5 <- differentialTest(formula = ~ Group + AR_status,
                          phi.formula = ~ Group + AR_status,
                          formula_null = ~ 1,
                          phi.formula_null = ~ Group + AR_status,
                          data = dx,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.05)
plot(ex5, color = "Group", B = 50)




ex5$significant_taxa
ex5$all_models
ex5$significant_models
ex5$full_output
samples


# Jointly testing for differential abundance across Day, and differential dispersion across Amdmt, controlling
# for the effect of Day on Dispersion:
ex6 <- differentialTest(formula = ~ Group,
                          phi.formula = ~ Group + AR_status,
                          formula_null = ~ 1,
                          phi.formula_null = ~ Group,
                          data = dx,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.05)
plot(ex6)


ex8 <- differentialTest(formula = ~ Group_Type,
                        phi.formula = ~ Group_Type,
                        formula_null = ~ 1,
                        phi.formula_null = ~ 1,
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.05)
plot(ex8, level = "class")


#Jointly testing for differential abundance and differential variability across Day(Group), controlling for the effect of
# Amdmt on abundance only (age and sex, Group-type):
exr <- differentialTest(formula = ~ Group + Age + Gender,
                          phi.formula = ~ Group,
                          formula_null = ~ Age +Gender,
                          phi.formula_null = ~ 1,
                          data = dx,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.05)
plot(exr)
exr$significant_taxa
samples

tiff("Group_asthma.tiff", units="in", width=5, height=5, res=500)
plot(exr)
dev.off()

exr <- differentialTest(formula = ~ Allergic_rhinitis + Age + Gender,
                        phi.formula = ~ Allergic_rhinitis,
                        formula_null = ~ Age +Gender,
                        phi.formula_null = ~ 1,
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.05)
plot(exr)
exr$significant_taxa
samples

tiff("Group_AR.tiff", units="in", width=5, height=5, res=500)
plot(exr)
dev.off()


# Testing for differential abundance across Day, controlling for the effect of Day on dispersion:
  ex2 <- differentialTest(formula = ~ Day,
                          phi.formula = ~ Day,
                          formula_null = ~ 1,
                          phi.formula_null = ~ Day,
                          data = soil_full,
                          test = "Wald", boot = FALSE,
                          fdr_cutoff = 0.01)
plot(ex2)


exr <- differentialTest(formula = ~ Allergic_rhinitis + Age + Gender, #meanfitted to abundance
                        phi.formula = ~ Allergic_rhinitis,# model fitted dispersion 
                        formula_null = ~ Age + Gender,#meanwithout response
                        phi.formula_null = ~ Allergic_rhinitis,#dispersion without response
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.001)
plot(exr)
exr$significant_taxa

otu_to_taxonomy(OTU = da_analysis$significant_taxa, data = dx)







tiff("Group_AR20.01.tiff", units="in", width=5, height=5, res=500)
plot(exr)
dev.off()

exr2 <- differentialTest(formula = ~ Allergic_rhinitis + Age + Gender + Group_Type, #meanfitted to abundance
                        phi.formula = ~ Allergic_rhinitis + Age + Gender + Group_Type,# model fitted dispersion 
                        formula_null = ~ Age +Gender + Group_Type,#meanwithout response
                        phi.formula_null = ~ Allergic_rhinitis + Age + Gender + Group_Type,#dispersion without response
                        data = dx,
                        test = "Wald", boot = FALSE,
                        fdr_cutoff = 0.0000001)
plot(exr2)
exr2$p_fdr < 0.00001

exr2$significant_taxa 
plot(exr2)
exr2$significant_taxa
tiff("Group_ARspecies.tiff", units="in", width=5, height=5, res=500)
plot(exr2)
dev.off()
xx3<-exr2$significant_taxa
write.csv(xx3,"exrx$significant_taxaAR_species.csv" )

otu_to_taxonomy(OTU = da_analysis$significant_taxa, data = dx)

dx





xx<-exr2$significant_taxa
write.csv(xx,"exr2$significant_taxa25.csv" )

exrx <- differentialTest(formula = ~ Asthma + Age + Gender + Group_Type, #mean fitted to abundance
                         phi.formula = ~ Asthma + Age + Gender + Group_Type,# model fitted dispersion 
                         formula_null = ~ Age +Gender + Group_Type,#meanwithout response
                         phi.formula_null = ~ Asthma + Age + Gender + Group_Type,#dispersion without response
                         data = dx,
                         test = "Wald", boot = FALSE,
                         fdr_cutoff = 0.001)
plot(exrx)

tiff("Asthma_adjustedall0.001species2.tiff", units="in", width=5, height=5, res=500)
plot(exrx)
dev.off()

rf<-otu_to_taxonomy(OTU = exrx$significant_taxa, data = dx)
write.csv(rf,"exrx$significant_taxa_asthma2.csv" )
rf



exrx$significant_taxa
xx2<-exrx$significant_taxa
write.csv(xx2,"exrx$significant_taxa25_species.csv" )







exr2 <- differentialTest(formula = ~ Allergic_rhinitis + Age + Gender, #meanfitted to abundance
                         phi.formula = ~ Allergic_rhinitis + Age + Gender,# model fitted dispersion 
                         formula_null = ~ Age +Gender,#meanwithout response
                         phi.formula_null = ~ Allergic_rhinitis + Age + Gender,#dispersion without response
                         data = dx,
                         test = "Wald", boot = FALSE,
                         fdr_cutoff = 0.001)
plot(exr2)

plot(exr2)
exr2$significant_taxa
plot(exr2)
exr2$significant_taxa
dfx2x<-otu_to_taxonomy(OTU = exr2$significant_taxa, data = dx)

write.csv(dfx2x,"exrx$significant_taxaAR2.csv" )

rfx<-otu_to_taxonomy(OTU = exr2$significant_taxa, data = dx)
write.csv(rfx,"exrx$significant_taxa_AR2.csv" )
rfx







exr2
tiff("Group_Asthma_0.05adjustedall.tiff", units="in", width=5, height=5, res=500)
plot(exr2)
dev.off()

exr2$significant_models
exr2$significant_taxa
samples










# break code

set.seed(1)
differentialTest(formula = ~ Group,
                                phi.formula = ~ Group,
                                formula_null = ~ 1,
                                phi.formula_null = ~ Group,
                                test = "Wald", boot = FALSE,
                                data = dx,
                                fdr_cutoff = 0.05)


plot.differentialTest <- function(x, level = NULL, data_only = FALSE, ...) {
  signif_taxa <- x$significant_taxa
  if ("phyloseq" %in% class(x$data)) {
    if (!is.null(x$data@tax_table)) {
      signif_taxa <- otu_to_taxonomy(signif_taxa, x$data, level = level)
      if (length(unique(signif_taxa)) != length(unique(x$significant_taxa))) {
        # Make sure if repeated taxa add unique otu identifiers
        signif_taxa <- paste0(signif_taxa, " (", x$significant_taxa, ")")
      }
    }
  }
  if (length(x$significant_models) != 0) {
    var_per_mod <- length(x$restrictions_DA) + length(x$restrictions_DV)
    total_var_count <- length(signif_taxa) * var_per_mod
    df <- as.data.frame(matrix(NA, nrow = total_var_count, ncol = 5))
    colnames(df) <- c("x", "xmin", "xmax", "taxa", "variable")
    qval <- stats::qnorm(.975)
    restricts_mu <- attr(x$restrictions_DA, "index")
    restricts_phi <- attr(x$restrictions_DV, "index")
    
    count <- 1
    for (i in 1:length(x$significant_models)) {
      
      # Below from print_summary_bbdml, just to get coefficient names
      tmp <- x$significant_models[[i]]
      coefs.mu <- tmp$coefficients[1:tmp$np.mu,, drop = FALSE]
      rownames(coefs.mu) <- paste0(substring(rownames(coefs.mu), 4), "\nDifferential Abundance")
      coefs.mu <- coefs.mu[restricts_mu,, drop = FALSE]
      
      coefs.phi <- tmp$coefficients[(tmp$np.mu + 1):nrow(tmp$coefficients),, drop = FALSE]
      rownames(coefs.phi) <- paste0(substring(rownames(coefs.phi), 5), "\nDifferential Variability")
      coefs.phi <- coefs.phi[restricts_phi - tmp$np.mu,, drop = FALSE]
      
      coefs <- rbind(coefs.mu, coefs.phi)
      for (j in 1:var_per_mod) {
        df[count, 1:3] <- c(coefs[j, 1], coefs[j, 1] - qval * coefs[j, 2],
                            coefs[j, 1] + qval * coefs[j, 2])
        df[count, 4:5] <- c(signif_taxa[i], rownames(coefs)[j])
        count <- count + 1
      }
    }
    if (!(data_only)) {
      # global variables warning suppression
      taxa <- xmin <- xmax <- NULL
      
      ggplot2::ggplot(df, ggplot2::aes(x = x, y = taxa)) +
        ggplot2::geom_vline(xintercept = 0, color = "gray50", lty = "dashed",
                            alpha = 0.75, lwd = 1) +
        ggplot2::geom_point() +
        ggplot2::geom_errorbarh(ggplot2::aes(xmin = xmin, xmax = xmax, colour = NULL), height = .3) +
        ggplot2::theme_bw() +
        ggplot2::facet_wrap(~variable, scales = "free_x", nrow = 1) +
        ggplot2::labs(title = "", x = "Regression coefficient", y = "Taxa") +
        ggplot2::scale_y_discrete(limits = rev(df$taxa)) +
        ggplot2::scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
    } else {
      return(df)
    }
  } else {
    message("No taxa were found to be significantly different using your model specification. \nPlease verify that your formulas are correctly specified.")
  }
}

library(tidyverse)
library(magrittr)
library(glmnet)
library(pROC)
# Lasso anaysis microbidal data 

dat<-read.csv("Lasso_specoesdata.csv", row.names = 1)
dat<-read.csv("Lasso_specoesdata2.csv", row.names = 1)


y<-dat$Asthma
x<-model.matrix(y~., dat[,-1])
#x<-model.matrix(y~., dat[,-1])
#glmnet(x, y, family = "binomial", alpha = 1, lambda = NULL)
cv.fit <- cv.glmnet(x,y, family="binomial", alpha= 0.8)
plot(cv.fit)
fit <- glmnet(x,y, family = "binomial", alpha = 0.8)
plot(fit)
cv.fit$lambda.min

Coefficients <- coef(fit, s = fit$lambda.min)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
coef(cv.fit, s = "lambda.min")


dev.off()


library(ggplot2)
library(magrittr)
library(dplyr)
library(ggpubr)





install.packages("gbarplot")
dt<-read.csv("Lassoadjcoef_SP.csv")
dt<-read.csv("Lassoadjcoef_SPx2.csv")
dt<-read.csv("DEG_ETH_ISR.csv" )
dim(dt)
dt<-read.csv("DEGs_ISR23P0.05.csv" )
dim(dt)
dt<-read.csv("DEG_ETH.csv" )
dim(dt)
dt<-read.csv("DEGs_ETH_ISR0.05.csv" )
dim(dt)



dt$ID
dt$ID
dt$coef
dt$method
dt$logFC
dt$padj
#palette = c("#00AFBB", "#E7B800", "#FC4E07"), # Custom color palette

ggbarplot(dt, x = "ID", y = "logFC",
          fill = "Method",           # change fill color by mpg_level
          color = "white",            # Set bar border colors to white
          palette = c("#00AFBB"), # jco journal color palett. see ?ggpar
          sort.val = "asc",          # Sort the value in descending order
          sort.by.groups = T,     # Don't sort inside each group
          x.text.angle = 90,          # Rotate vertically x axis texts
          ylab = "Effect Size",
          xlab = "",
          legend.title = " ",
          legend = "none",
          rotate = TRUE,
          cex = 1,
          font.caption = "bold",
          font.x = c(8, "bold", "black"),
          font.y = c(8, "bold", "black"),
          font.tickslab = c(8,"bold", "black"),
          ggtheme = theme_minimal()
)






tiff("Lasso_asthma_Taxa.tiff", units="in", width=5, height=5, res=300)
ggbarplot(dt, x = "logFC", y = "ID",
          fill = "Method",           # change fill color by mpg_level
          color = "white",            # Set bar border colors to white
          palette = c("#FC4E07"), # jco journal color palett. see ?ggpar
          sort.val = "asc",          # Sort the value in descending order
          sort.by.groups = T,     # Don't sort inside each group
          x.text.angle = 90,          # Rotate vertically x axis texts
          ylab = "Effect Size",
          xlab = "",
          legend.title = " ",
          legend = "none",
          rotate = TRUE,
          cex = 1,
          font.caption = "bold",
          font.x = c(8, "bold", "black"),
          font.y = c(8, "bold", "black"),
          font.tickslab = c(8,"bold", "black"),
          ggtheme = theme_minimal()
)



dev.off()

dt<-read.csv("Cytokine_GSEA2.csv" )
dim(dt)



ggbarplot(dfm, x = "name", y = "mpg_z",
          fill = "mpg_grp",           # change fill color by mpg_level
          color = "white",            # Set bar border colors to white
          palette = "jco",            # jco journal color palett. see ?ggpar
          sort.val = "desc",          # Sort the value in descending order
          sort.by.groups = FALSE,     # Don't sort inside each group
          x.text.angle = 90,          # Rotate vertically x axis texts
          ylab = "MPG z-score",
          legend.title = "MPG Group",
          rotate = TRUE,
          ggtheme = theme_minimal()
)











# how to install the introdataviz package to get split and half violin plots
devtools::install_github("psyteachr/introdataviz")
library(introdataviz)
dt<-read.csv("Lassoadjcoef_SP.csv")
dat<-read.csv("Lasso_specoesdata.csv", row.names = 1)

dat$Immigrant_status
dat$Asthma
dat$Alistipes.sp..CAG.831
dat$Group

ggplot(dat, aes(x = Immigrant_status , y = Alistipes.sp..CAG.831, fill = Asthma)) +
  introdataviz::geom_split_violin(alpha = .4, trim = FALSE) +
  geom_boxplot(width = .2, alpha = .6, fatten = NULL, show.legend = FALSE) +
  stat_summary(fun.data = "mean_se", geom = "pointrange", show.legend = F, 
               position = position_dodge(.175)) +
  scale_x_discrete(name = "Immigrant_status", labels = c("Nonimmigrant", "Immigrant")) +
  scale_y_continuous(name = "Taxa differential abundance") +
                      
  scale_fill_brewer(palette = "Dark2", name = "Asthma") +
  theme_minimal()


dat$Group
table(dat$Group)

p <- ggboxplot(dat, x = "Group", y = "Alistipes.sp..CAG.831",
               color = "Group", palette =c("#00AFBB", "#E7B800", "#FC4E07"),
               add = "jitter", shape = "Group")
p



# Add p-values comparing groups
# Specify the comparisons you want
my_comparisons <- list( c("Eth-AS", "Eth-Ctrl"), c("Eth-AS", "ISR-AS"), c("ISR-AS", "ISR-Ctrl") )
p + stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 8) 

# Violin plots with box plots inside
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change fill color by groups: dose
# add boxplot with white fill color
ggviolin(df, x = "dose", y = "len", fill = "dose",
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),
         add = "boxplot", add.params = list(fill = "white"))+
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y = 50)          




#Abundance bar plot

dx <- phyloseq(OTU, TAX, samples)
dx
sample_names(dx)
rank_names(dx)
sample_variables(dx)
samples
TAX


# agglomerate taxa
glom <- tax_glom(dx, taxrank = 'Species', NArm = FALSE)
ps.melt <- psmelt(glom)
# change to character for easy-adjusted level
ps.melt$Species <- as.character(ps.melt$Species)

ps.melt <- ps.melt %>%
  group_by(Asthma, Species) %>%
  mutate(median=median(Abundance))
# select group median > 1
keep <- unique(ps.melt$Species[ps.melt$median > 1])
ps.melt$Species[!(ps.melt$Species %in% keep)] <- "< 1%"
#to get the same rows together
ps.melt_sum <- ps.melt %>%
  group_by(Sample,Asthma,Species) %>%
  summarise(Abundance=sum(Abundance))

ggplot(ps.melt_sum, aes(x = Sample, y = Abundance, fill = Species)) + 
  geom_bar(stat = "identity", aes(fill=Species)) + 
  labs(x="", y="%") +
  facet_wrap(~ Asthma, scales= "free_x", nrow=1) +
  theme_classic() + 
  theme(strip.background = element_blank(), 
        axis.text.x.bottom = element_text(angle = -90))


#PERMANOVA significance test for group-level differences

# samples x species as input
library(vegan)
library(microbiome)
library(ggplot2)
library(dplyr)
OTU
dx
dx4 = filter_taxa(dx3, function(x) sum(x > 2) > (0.11 * length(x)), TRUE) 
d<-as.matrix(otu_table(dx4))
d
dim(t(d))



# P-value
print(as.data.frame(permanova$aov.tab)["Group_Type", "Pr(>F)"])

dist <- vegdist(t(OTU))
anova(betadisper(dist, d$Group_Type))
d$Group_Type
dist
coef <- coefficients(permanova)["Ethio",]
top.coef <- coef[rev(order(abs(coef)))[1:2]]
par(mar = c(3, 14, 2, 1))
barplot(sort(top.coef), horiz = T, las = 1, main = "Top taxa")
d$Group_Type


samples


BC.nmds = metaMDS(OTU, distance="bray", k=2, trymax=1000)

par(mfrow = c(1, 1))
#Create a blank plot for the nmds
plot(BC.nmds, type="n", main="Bray-Curtis")
#Add the points colored by age
points(BC.nmds, display="sites", pch=20, col=c("blue", "green", "red")[samples])
#Add a legend
legend(-5.5, 2.5, legend=c("2w","8w","1yr"), col=c("green","red","blue"), pch=20)
samples$

  
J.nmds = metaMDS(OTU.clean, distance="jaccard", k=2, trymax=1000)

plot(J.nmds, type="n", main="Jaccard")
points(J.nmds, display="sites", pch=20, col=c("blue", "green", "red")[meta$AgeGroup])
legend(-3, 1.5, legend=c("2w","8w","1yr"), col=c("green","red","blue"), pch=20)


plot(BC.nmds, type="n", main="Bray-Curtis")
legend(-5.5, 2.5, legend=c("2w","8w","1yr"), col=c("green","red","blue"), pch=20)

#Add an ellipse for 2w
ordiellipse(BC.nmds, groups=meta$AgeGroup, display="sites", kind="se", conf=0.99, label=FALSE, col="green", draw="polygon", alpha=200, show.groups = c("2w"), border=FALSE)

#Add an ellipse for 8w
ordiellipse(BC.nmds, groups=meta$AgeGroup, display="sites", kind="se", conf=0.99, label=FALSE, col="red", draw="polygon", alpha=200, show.groups = c("8w"), border=FALSE)

#Add an ellipse for 1yr
ordiellipse(BC.nmds, groups=meta$AgeGroup, display="sites", kind="se", conf=0.99, label=FALSE, col="blue", draw="polygon", alpha=200, show.groups = c("1yr"), border=FALSE)

#3d plot
#Calculate the Bray-Curtis nMDS for 3-axis
BC.nmds.3D = metaMDS(OTU.clean, distance="bray", k=3, trymax=1000)

BCxyz = scores(BC.nmds.3D, display="sites")
#This is a table that looks like 
BCxyz
plot_ly(x=BCxyz[,1], y=BCxyz[,2], z=BCxyz[,3], type="scatter3d", mode="markers", color=meta$AgeGroup, colors=c("blue", "green", "red"))


#correlation analysis 
library(Hmisc)
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
  )
}

df<-read.csv("metabolic_speciesData.csv", row.names = 1)
df<-read.csv("corPath_DAA_asthmatic_ETHIOISR2.csv", row.names = 1)
df<-read.csv("cormeta_data_DNA_tabolitDatax.csv", row.names = 1, check.names = FALSE)



rx<-rcorr(as.matrix(df))

rx$r

rx2<-flattenCorrMatrix(rx$r, rx$P)
write.csv(rx2, "corPath_cormeta_data_DNA_tabolitDataFinal.csv")

# data-integration and differential network analysis

install.packages("remotes")
remotes::install_github("kuppal2/xMWAS")
library(xMWAS)
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install(c("DECIPHER","DESeq2", "philr", "phyloseq"))

BiocManager::install("preprocessCore")
BiocManager::install("GO.db")
BiocManager::install("impute")

install.packages(c("adespatial","ape","devtools","ggdendro","gridExtra","knitr","MicrobeR","pander","plotly","png","tidyverse","vegan"))


library(devtools)

devtools::install_github("gauravsk/ranacapa")
devtools::install_github("umerijaz/microbiomeSeq") 
library(microbiomeSeq)
install.packages("remotes")

remotes::install_github("jbisanz/qiime2R")
remotes::install_github("jbisanz/MicrobeR")

#New Packages:
  
  remotes::install_github("microsud/microbiomeutilities")
BiocManager::install("microbiome")

install.packages(c("ggpubr", "RColorBrewer"))

install.packages("bit64")

#
library(phyloseq)
library(ggplot2)      
library(readxl)       
library(dplyr)        
library(tibble) 



OTU = otu_table(otu_mat, taxa_are_rows = TRUE)
TAX = tax_table(tax_mat)
samples = sample_data(samples_df)
OTU
TAX 
#Transform to phyloseq objects
dx <- phyloseq(OTU, TAX, samples)
dx
#normalized the data
total = median(sample_sums(dx))
standf = function(x, t=total) round(t * (x / sum(x)))
dx = transform_sample_counts(dx, standf)




plot_bar(dx, fill = "Species")

plot_bar(dx, fill = "Species") + 
  geom_bar(aes(color=Species, fill=Species), stat="identity", position="stack")

plot_heatmap(dx, method = "MDS", distance = "(A+B-2*J)/(A+B-J)", 
             taxa.label = "Species", taxa.order = "Species", 
             trans=NULL, low="beige", high="red", na.value="beige")




plot_heatmap(dx, method = "NMDS", distance = "bray", 
             taxa.label = "Species", taxa.order = "Species", 
             low="beige", high="red", na.value="beige")



# Simple network analysis

plot_net(dx, distance = "(A+B-2*J)/(A+B)", type = "taxa", 
         maxdist = 0.7, color="Species", point_label="Species")


plot_net(dx, distance = "(A+B-2*J)/(A+B)", type = "taxa", 
         maxdist = 0.8, color="Species", point_label="Species") 


install.packages("xfun", type="binary")

#heatmap between metaboloite and microbime

library(corrplot)
library(Hmisc) 
library(psych)


# Computes correlation and p-value matrix
dt<-read.csv("cormeta_data.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("Asthma_control_metabolote_sp.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("SP_metbolic_asthmaticEthioISR_only.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("SP_metbolic_ISR_only.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("metabolite_ethioISR_asthmatic_top20SP.csv", row.names = 1, check.names = FALSE)

dt<-read.csv("cytokine-metabolite_intraction2.csv", row.names = 1, check.names = FALSE)

dt<-read.csv("cytokine-metabolite_intraction2_normalizedxAUC_metabolite.csv", row.names = 1, check.names = FALSE)

dt<-read.csv("cytokine-metabolite_intraction23_asthmaonly.csv", row.names = 1, check.names = FALSE)

dt<-read.csv("cytokine-metabolite_intraction23_asthmaonlyx.csv", row.names = 1, check.names = FALSE)


# microbiom analysis 

dat<-read.csv("ISR_DAdata23x_AC.csv", row.names = 1, check.names = F)
dat<-read.csv("DA_SP_CorrelatedCpG_All_AS.csv", row.names = 1,check.names = F )
dat<-read.csv("OTU_Ethi0_only_species_abundetData_DAAlog10_AS.csv", row.names = 1, check.names = F)
dat$AR<-as.factor(dat$AR)
dat$Gender<-as.factor(dat$Gender)
dim(dat)
head(dat)

dt<-read.csv("ISR_DAdata23x_AC_corr2.csv", row.names = 1, check.names = FALSE)









??corrplot
getwd()
par(mar = c(2, 2, 2, 2))

dim(dt)
dt
cex.before <- par("cex")
par(cex = 0.4)
Mp <- rcorr(as.matrix(dt))


col<- colorRampPalette(c("blue", "white", "red"))(20)
col=colorRampPalette(c("blue","white","red"))(20)
#SP_metbolic_asthmaticEthioISR_onlyMatch2


#pdf("cytokine-metabolite_intraction23x.pdf", width=20, height=15)
png("CpG_SP2.png", width=5, height=30, units="in", res=300)
#cex.before <- par("cex")
#par(cex = 0.4) #1:73, 74:116
corrplot(Mp$r[1:340, 3721:3744], method="color", col = col, tl.col = "black" ,
         
         tl.cex = 1,
          cl.cex = 1)


dev.off()













#cytokine data analysis 
dt<-read.csv("Corr_DNA_asthma_control_sigselected.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("Cytokine_asthmatic_controllog10_ISR.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("Cytokineasthmatic_controllog10_Ethiox.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("SP_methabolite_Ethio.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("Cytoline_metabolite_top20_ethioISR_asthmatic.csv", row.names = 1, check.names = FALSE)


#methylTION

#cytokine data analysis 
dt<-read.csv("ETH_asthmacontrol_sp_methylation.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("ISR_asthmacontrol_sp_methylation.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("ETHISR_asthmatic_sp_methylationsp20.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("microbimeSP_DMCs_ISRlog10x.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("ETH_asthmacontrol_sp_methylation2.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("25ETH.methylation2mached.microbimeData.csv", row.names = 1, check.names = FALSE)
dt<-read.csv("DEG_AS_genus_abundance80%_metabolite2.csv", row.names = 1, check.names = FALSE)






rm(list = ls())
dim(dt)
cex.before <- par("cex")
par(cex = 0.4)

Mp <- rcorr(as.matrix(dt[]))
Mp2 <- rcorr(as.matrix(dt[1:10,]))
col<- colorRampPalette(c("blue", "white", "red"))(20)
col=colorRampPalette(c("blue","white","red"))(20)

png("metabolite_micrbiome231.png", width=30, height=20, units="in", res=300)

#png("pic_EthioISR_cytokine_associationFig.png")

corrplot(Mp$r[1:21, 22:64], p.mat=Mp$P[1:21, 22:64],
         method="color", col = col, tl.col = "black", sig.level = c(0.001, 0.01, 0.05), insig = 'label_sig',
         
         tl.cex = 3,
         cl.cex = 1) 


dev.off()


library(psych)


myfun <- function(df) corr.test(df[, 2:22], df[, 23:30], method = "spearman", adjust = 
                                  "none")$p

dfs <- by(dt, dt$Group, myfun)
mat <- do.call(rbind, dfs)

library(pheatmap)
pheatmap(mat, 
         cluster_rows = F, 
         cluster_cols = F, 
         display_numbers = F, 
         show_rownames = T,
         show_colnames = T,
         number_format = "%.4f")














myfun <- function(df) corr.test(df[, 1], df[, 3:6], method = "spearman", adjust = 
                                  "none")$p
dfs <- by(mtcars, mtcars$cyl, myfun)
mat <- do.call(rbind, dfs)
rownames(mat) <- c("cyl = 4", "cyl = 6", "cyl = 8")












# missing value estimation in R 
install.packages("mice")
library(mice)
dtx<-read.csv("SpecificIGE.csv", row.names = 1)
dtx
mputed_dtx <- mice(dtx, m=5, maxit = 50, method = 'pmm', seed = 500)
mputed_dtx
write.csv(mputed_dtx, "m.csv")
mputed_dtx
summary(mputed_dtx)

mputed_dtx

dtx<-read.csv("asthmaticprevalence_80%andmorex.csv", row.names = 1, check.names = FALSE)
dtx2<-log10(dtx +1)
write.csv(dtx2, "EthioISR_asthmalog10x.csv")






library(Amelia)
dtx
#seed 10% missing values
dtx2 <- prodNA(dtx)
summary(dtx2)
dtx<-read.csv("SpecificIGE.csv", row.names = 1)
dtx$Betv1<-as.factor(dtx)
dtx<-as.matrix(dtx)
x<- prodNA(dtx, noNA = 0.1)
library(missForest)
install.packages("missForest")
dtx
rfx <- prodNA(dtx, noNA = 0.1)
rx.imp <- missForest(rfx)
rx.imp2<-rx.imp$ximp
write.csv(rx.imp2, "rx.imp2.csv")

library(EnhancedVolcano)
library(DESeq2)
d<-read.csv("DEGs_species_abundance_EthiISR_asthmaControl.csv", row.names = 1, check.names = FALSE)
d<-read.csv("DEGs_species_abundance_Asthmatic-Ethi_ISR.csv", row.names = 1, check.names = FALSE)
d<-read.csv("DEGs_species_abundance_Asthmatic-Ethi_only.csv", row.names = 1, check.names = FALSE)
d<-read.csv("DEGs_species_abundance_ISRONLY.csv", row.names = 1, check.names = FALSE)
d<-read.csv("DEGs_species_abundance_EthiISR_Control.csv", row.names = 1, check.names = FALSE)

d<-read.csv("All_DAdata23x_Rg_exposure_sp2x_sig.csv", row.names = 1, check.names = FALSE)






df$ID2
library(dplyr)
library(ggplot2)
nudge <- 0.1

df |> 
  mutate(
    sig_label = case_when(
      padj < 0.001 ~ "***",
      padj < 0.01 ~ "**",
      padj < 0.05 ~ "*",
      padj >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge, log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.7,show.legend = T)+ theme_bw() + facet_wrap(~ ID2)+
  theme(axis.text.x = element_text(size =10, angle = 45, hjust = 1 , colour = "black")) +
  geom_text(aes(label = sig_label, y = label_position))


tiff("metabolite.tiff", units="in", width=5, height=5, res=300)

df$p.value
df$Wilcox.rank
df |> 
  mutate(
    sig_label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      p.value >= 0.05 ~ ""
    ),
    label_position = ifelse(Wilcox.rank > 0, Wilcox.rank + nudge, Wilcox.rank - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = Wilcox.rank , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.6,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black")) +
  geom_text(aes(label = sig_label, y = label_position))




dx<-read.csv("outwith80%data_EthioISR_asthmaControlx.csv", row.names = 1)
dx2<-log10(dx +1)
write.csv(dx2,"outwith80%data_EthioISR_asthmaControlxlog10.csv" )

df<-read.csv("t_test.csv", row.names = 1)
df<-read.csv("t_test_cytokine.csv", row.names = 1)

df<-read.csv("metabolite_FC.csv", row.names = 1)
df<-read.csv("Cytokine_FC_AUC.csv", row.names = 1)
df<-read.csv("metabolite_FC.csv", row.names = 1)



df$log2FC
df$Pvalue
df$ID2
df$padj
png("metabolote_FC_final2.png", width=8, height=3, units="in", res=300)
colour

df |> 
  mutate(
    sig_label = case_when(
      Pvalue < 0.001 ~ "***",
      Pvalue < 0.01 ~ "**",
      Pvalue < 0.05 ~ "*",
      Pvalue >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge , log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.4,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
  geom_text(aes(y = label_position + 0.000005, label = sig_label)) + theme(axis.title.x = element_blank())


dev.off()

df<-read.csv("DEG_AS80p.csv", row.names = 1)

df<-read.csv("AS_ETH_ISR_DEG.csv", row.names = 1, check.names = FALSE)
df<-read.csv("AS_ISR_DEG.csv", row.names = 1, check.names = FALSE)
df<-read.csv("AS_ETH_DEG.csv", row.names = 1, check.names = FALSE)

df$ID2
df$padj

png("AS_ETH_DEG.png", width=6, height=3, units="in", res=300)

nudge <- 0.5

df |> 
  mutate(
    sig_label = case_when(
      padj < 0.001 ~ "***",
      padj < 0.01 ~ "**",
      padj < 0.05 ~ "*",
      padj >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge , log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.2,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =5, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
  geom_text(aes(y = label_position + 0.05, label = sig_label)) + theme(axis.title.x = element_blank())


dev.off()































d<-read.csv("bVals_final2_Asthma_control_ETH_mapped2.csv", row.names = 1)
d<-read.csv("bVals_final2_Asthma_control_ISR_mapped.csv", row.names = 1)
d<-read.csv("DMCs_wilcox_DMCS2_Pvalue_twosided_annotated_allXYRemove.csv", row.names = 1)
d<-read.csv("merge_All_CpG_micrbiomecorelated_DMCs.csv", row.names = 1)
d<-read.csv("ETH_CpG_micrbiomecorelated_DMCs_mapped.csv", row.names = 1)
d<-read.csv("bVals_final2_Asthma_control_ISR_mapped2.csv", row.names = 1)
d<-read.csv("All_CpG_micrbiomecorelated_DMCs_mapped2_revised.csv", row.names = 1)
d<-read.csv("All_CpG_micrbiomecorelated_DMCs_mapped2_revised.csv", row.names = 1)
res2<-read.csv("DMCs_All2x.csv", row.names = 1)
res2<-read.csv("DMCs_ISR.csv", row.names = 1)
res2<-read.csv("DMCs_ETH.csv", row.names = 1)
res2<-read.csv("AUC-metabolite_cytokinex.csv", row.names = 1)
res2

res2<-read.csv("ETH_log10auto.csv", row.names = 1)
res2
res2<-read.csv("log10Autonormalization_ISR.csv", row.names = 1)
res2





# 'Ornithine','Glutamate'# ETH

#'Methionine', 'Lysine', 'Ornithine', 'Creatine', 'O-Phosphocholine', 'Choline' ETH+ISR

#'Choline','2-Hydroxybutyrate','Isobutyrate','Lysine' # ISR




??EnhancedVolcano

library(DESeq2)


library(EnhancedVolcano)

FC <- 0.005486624 # all
p <- 0.006232355

FC <- 0.023068394 # ISR
p <- 0.008969521

FC <- 0.00829032 # ETH
p <- 0.011181327


FC <- 0.01 # ETH
p <- 0.05




keyvals <- rep('grey25', nrow(res2))
names(keyvals) <- rep('NS', nrow(res2))


keyvals[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'NS'

keyvals[which(abs(res2$log2FoldChange) < FC & res2$pvalue < p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange)  < FC & res2$pvalue < p)] <- 'NS'

keyvals[which(res2$log2FoldChange < -FC & res2$pvalue < p)] <- 'green3'
names(keyvals)[which(res2$log2FoldChange  < -FC & res2$pvalue < p)] <- 'Hypo'

keyvals[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'green3'
names(keyvals)[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'Hyper'

unique(keyvals)
unique(names(keyvals))





keyvals <- rep('grey25', nrow(res2))
names(keyvals) <- rep('NS', nrow(res2))


keyvals[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'NS'

keyvals[which(abs(res2$log2FoldChange) < FC & res2$pvalue < p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange)  < FC & res2$pvalue < p)] <- 'NS'

keyvals[which(res2$log2FoldChange < -FC & res2$pvalue < p)] <- 'green3'
names(keyvals)[which(res2$log2FoldChange  < -FC & res2$pvalue < p)] <- 'Hypo'

keyvals[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'green3'
names(keyvals)[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'Hyper'

unique(keyvals)
unique(names(keyvals))














png("ETHRmetabolite-asthmatic vs cos4.png", width=10, height=6, units="in", res=300)


EnhancedVolcano(res2,
                lab = rownames(res2),
                x = 'log2FoldChange',
                y = 'pvalue',
                selectLab = c('Ornithine','Glutamate'),
                #selectLab = rownames(res2)[which(names(keyvals) %in% c('Hyper'))],
                xlim = c(-0.9,0.9),
                xlab = 'Effect Size',
                
                ylab = bquote(~-Log[10] ~ italic((P))),
                title = 'ETH-asthmatic vs ETH-control',
                subtitle = " ",
                pCutoff = 0.06,
                FCcutoff = 0.01,
                pointSize = 2.5,
                labSize = 3,
                colCustom = keyvals,# colCustom = keyvals
                colAlpha = 0.75,
                legendPosition = 'right',
                caption = "",
                legendLabSize = 12,
                legendIconSize = 3.0,
                drawConnectors = FALSE,
                widthConnectors = 0.5,
                colConnectors = 'grey25',
                gridlines.major = T,
                gridlines.minor = FALSE,
                border = 'partial',
                borderWidth = 1.5,
                borderColour = 'black')

dev.off()






EnhancedVolcano(res2,
                lab = rownames(res2),
                x = 'log2FoldChange',
                y = 'pvalue',
                selectLab = c(''),
                #selectLab = rownames(res2)[which(names(keyvals) %in% c('NS','log2FoldChange','-Log10Q','low','high'))],
                xlim = c(-0.8,0.8),
                xlab = 'Effect Size',
                
                ylab = bquote(~-Log[10] ~ italic((P))),
                title = 'ISR-asthmatic vs ISR-control',
                subtitle = " ",
                pCutoff = 0.05,
                FCcutoff = 0.01,
                pointSize = 2.5,
                labSize = 3,
                colCustom = keyvals,# colCustom = keyvals
                colAlpha = 0.75,
                legendPosition = 'right',
                caption = "",
                legendLabSize = 12,
                legendIconSize = 3.0,
                drawConnectors = FALSE,
                widthConnectors = 0.5,
                colConnectors = 'grey25',
                gridlines.major = T,
                gridlines.minor = FALSE,
                border = 'partial',
                borderWidth = 1.5,
                borderColour = 'black')





















P.Value
logFC


0.006232355


d$Effect.Size
d$PValue













d<-read.csv("DEGs_food.csv", row.names = 1, check.names = FALSE)
d$log2FoldChange
d$`P Value`
d$`Effect Size`
?EnhancedVolcano

EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'P Value')




d<-read.csv("All_metabolite_Rg_exposure_sp_Revised.csv", row.names = 1)
d$beta
d$pvalue




#Ethio+ISR-asthmatic vs Ethio+ISR-control

png("metabolite_SP_All2.png", width=10, height=6, units="in", res=300)
EnhancedVolcano(d,
                lab = rownames(d),
                x = 'Effect.Size',
                y = 'PValue',
                xlab = 'Effect Size',
                ylab = bquote(~-Log[10] ~ italic(PValue)),
                pCutoff = 0.006232355,
                FCcutoff = 0.005486624,
                pointSize = 3.0,
                labSize = 2.0,
                colAlpha = 1,
                titleLabSize = 12,
                title = '',
                subtitle = "ETH+ISR-asthmatic vs ETH+ISR-control ",
                caption = "",
                
                legendLabels=c('Not sig.','Effect Size','pvalue','pvalue and Effect Size'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = F,
                widthConnectors = 0.6)


dev.off()





pdf("Fig_ETH_ISR_AC.pdf", width=10, height=5)

EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'P Value',
                xlab = 'Effect Size',
                ylab = bquote(~-Log[10] ~ italic(padj)),
                pCutoff = 0.05,
                FCcutoff = 1.0,
                pointSize = 3.0,
                labSize = 3.0,
                colAlpha = 1,
                titleLabSize = 12,
                title = 'ETH-asthmatic vs ISR-asthmatic',
                subtitle = "",
                caption = "",
                
                legendLabels=c('Not sig.','Effect Size','padj','padj and Effect Size'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = TRUE,
                widthConnectors = 0.6)


dev.off()
dev.off()



d<-read.csv("All_DAdata23x_Rg_exposure_sp2x_sig.csv", check.names = FALSE, row.names = 1)

d<-read.csv("All_DAdata23x_Rg_exposure_sp.csv", check.names = FALSE, row.names = 1)


d<-read.csv("ISR_DAdata23x_Rg_exposure_sp2x2final.csv", check.names = FALSE, row.names = 1)





d$log2FoldChange
d$`P Value`
d$`Effect Size`
?EnhancedVolcano
d$pvalue
rownames(d)
EnhancedVolcano(d,
                lab = rownames(d),
                x = 'Effect Size',
                y = 'pvalue')

#Ethio+ISR-asthmatic vs Ethio+ISR-control
pdf("Fig_ETH_volcano.pdf", width=10, height=6)

EnhancedVolcano(d,
                lab = rownames(d),
                x = 'Effect Size',
                y = 'pvalue',
                xlab = 'Effect Size',
                ylab = bquote(~-Log[10] ~ italic(pvalue)),
                pCutoff = 0.001,
                FCcutoff = 0.1,
                pointSize = 3.0,
                labSize = 2.5,
                colAlpha = 1,
                titleLabSize = 12,
                title = '',
                subtitle = "",
                caption = "",
                
                legendLabels=c('Not sig.','Effect Size','pvalue','pvalue and Effect Size'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = TRUE,
                widthConnectors = 0.6)


dev.off()






pdf("Fig_ETH_ISR_AC.pdf", width=10, height=5)

EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'P Value',
                xlab = 'Effect Size',
                ylab = bquote(~-Log[10] ~ italic(padj)),
                pCutoff = 0.05,
                FCcutoff = 1.0,
                pointSize = 3.0,
                labSize = 3.0,
                colAlpha = 1,
                titleLabSize = 12,
                title = 'ETH-asthmatic vs ISR-asthmatic',
                subtitle = "",
                caption = "",
                
                legendLabels=c('Not sig.','Effect Size','padj','padj and Effect Size'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = TRUE,
                widthConnectors = 0.6)


dev.off()
dev.off()


#Tilahun Data 

d<-read.csv("Co-DR-100nM vs S-100nM.csv", check.names = FALSE, row.names = 1)

d<-read.csv("Dex-100nM vs Co-DR-100nM.csv", check.names = FALSE, row.names = 1)

res<-read.csv("Dex-100nM vs Co-DR-100nM.csv")
df<-res[!duplicated(res$ID),]
write.csv(df,"Dex-100nM vs Co-DR-100nM.dupremovx.csv")
df

library(DESeq2)


res2<-read.csv("Co-DR-100nM vs S-100nM.dupremov.csv", check.names = FALSE, row.names = 1)
res2<-read.csv("Control vs Co-DR-100nM.dupremov.csv", check.names = FALSE, row.names = 1)
res2<-read.csv("Control vs Dex-100nM.dupremov.csv", check.names = FALSE, row.names = 1)

res2<-read.csv("Control vs Rip-10uM.dupremov.csv", check.names = FALSE, row.names = 1)
res2<-read.csv("Dex-100nM vs S-100nM.dupremov.csv", check.names = FALSE, row.names = 1)


res2<-read.csv("Control vs S-100nM.dupremov.csv", check.names = FALSE, row.names = 1)
res2<-read.csv("Dex-100nM vs Co-DR-100nM.dupremovx.csv", check.names = FALSE, row.names = 1)

d$Effect.Size

??EnhancedVolcano

library(DESeq2)


library(EnhancedVolcano)

FC <- 1
p <- 0.05

keyvals <- rep('grey25', nrow(res2))
names(keyvals) <- rep('NS', nrow(res2))


keyvals[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange) > FC & res2$pvalue > p)] <- 'NS'

keyvals[which(abs(res2$log2FoldChange) < FC & res2$pvalue < p)] <- 'grey25'
names(keyvals)[which(abs(res2$log2FoldChange)  < FC & res2$pvalue < p)] <- 'NS'

keyvals[which(res2$log2FoldChange < -FC & res2$pvalue < p)] <- 'blue2'
names(keyvals)[which(res2$log2FoldChange  < -FC & res2$pvalue < p)] <- 'Down-regulated'

keyvals[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'red2'
names(keyvals)[which(res2$log2FoldChange > FC & res2$pvalue < p)] <- 'Up-regulated'

unique(keyvals)
unique(names(keyvals))



png("Dex-100nM vs Co-DR-100nM.png", width=10, height=6, units="in", res=300)


EnhancedVolcano(res2,
                lab = rownames(res2),
                x = 'log2FoldChange',
                y = 'pvalue',
                selectLab = c(''),
                #selectLab = rownames(res2)[which(names(keyvals) %in% c('NS','log2FoldChange','-Log10Q','low','high'))],
                xlim = c(-6.5,6.5),
                xlab = bquote(~Log[2]~ 'FC'),
                ylab = bquote(~-Log[10] ~ italic(Pvalue)),
                title = 'Dex-100nM vs Co-DR-100nM',
                subtitle = " ",
                pCutoff = 0.05,
                FCcutoff = 1,
                pointSize = 2.5,
                labSize = 3,
               colCustom = keyvals,# colCustom = keyvals
                colAlpha = 0.75,
                legendPosition = 'right',
                caption = "",
                legendLabSize = 12,
                legendIconSize = 3.0,
                drawConnectors = FALSE,
                widthConnectors = 0.5,
                colConnectors = 'grey50',
                gridlines.major = T,
                gridlines.minor = FALSE,
                border = 'partial',
                borderWidth = 1.5,
                borderColour = 'black')

dev.off()








getwd()



png("Control vs S-100nM_logFC0p0.05.png", width=10, height=6, units="in", res=300)
EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'padj',
                xlab = 'log2FoldChange',
                ylab = bquote(~-Log[10] ~ italic(padj)),
                pCutoff = 0.05,
                FCcutoff = 0,
                pointSize = 2.0,
                labSize = 2.0,
                colAlpha = 1,
                titleLabSize = 12,
                title = '',
                subtitle = "Control vs S-100nM ",
                caption = "",
                
                legendLabels=c('Not sig.','log2FoldChange','padj','padj and log2FoldChange'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = F,
                widthConnectors = 0.6)


dev.off()


















attach(topT)
cut_lfc <- 1
cut_pvalue <- 0.05

par(mar=c(5,5, 5, 5), cex=1.0, cex.main=1, cex.axis=1, cex.lab=1)
#par(mar=c(1,1,1,1))
# Adjusted P values
with(topT, xlim = c(-10, 10),
     
     plot(topT$log2FC, -log10(padj), pch=20, main=" NL vs H  ",
          col='black', cex=1, xlab= "log2(FC)", ylab= "-log10(padj)"))

with(subset(topT, padj<cut_pvalue & topT$log2FC>cut_lfc), 
     points(log2FC, -log10(padj), pch=20, col='red', cex=1))
with(subset(topT, padj<cut_pvalue & log2FC<(-cut_lfc)), 
     points(log2FC, -log10(padj), pch=20, col='blue', cex=1))

## Add lines for FC and P-value cut-off
abline(v=0, col='black', lty=3, lwd=1.0)
abline(v=-cut_lfc, col='black', lty=4, lwd= 1.0)
abline(v=cut_lfc, col='black', lty=4, lwd= 1.0)
abline(h=-log10(max(topT$padj[topT$padj <cut_pvalue], na.rm=TRUE)), col='black', lty=4, lwd=2.0)





























cut_lfc <- 1
cut_pvalue <- 0.05

par(mar=c(5,5,5,5), cex=1.0, cex.main=1.4, cex.axis=1.4, cex.lab=1.4)

# Adjusted P values
with(d, plot(log2FoldChange, -log10(pvalue), pch=20, main="Co-DR-100nM vs S-100nM", col='grey', cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~P~value)))

with(subset(d, pvalue<cut_pvalue & log2FoldChange>cut_lfc), points(log2FoldChange, -log10(pvalue), pch=20, col='red', cex=1.5))
with(subset(d, pvalue<cut_pvalue & log2FoldChange<(-cut_lfc)), points(log2FoldChange, -log10(pvalue), pch=20, col='blue', cex=1.5))

## Add lines for FC and P-value cut-off
abline(v=0, col='black', lty=3, lwd=1.0)
abline(v=-cut_lfc, col='black', lty=4, lwd=2.0)
abline(v=cut_lfc, col='black', lty=4, lwd=2.0)























d$log2FoldChange
d$padj


png("Control vs S-100nM_logFC0p0.05.png", width=10, height=6, units="in", res=300)
EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'padj',
                xlab = 'log2FoldChange',
                ylab = bquote(~-Log[10] ~ italic(padj)),
                pCutoff = 0.05,
                FCcutoff = 0,
                pointSize = 2.0,
                labSize = 2.0,
                colAlpha = 1,
                titleLabSize = 12,
                title = '',
                subtitle = "Control vs S-100nM ",
                caption = "",
                
                legendLabels=c('Not sig.','log2FoldChange','padj','padj and log2FoldChange'),
                legendPosition = 'right',
                legendLabSize = 8,
                legendIconSize = 3.0,
                drawConnectors = F,
                widthConnectors = 0.6)


dev.off()




EnhancedVolcano(d,
                lab = rownames(d),
                x = 'log2FoldChange',
                y = 'padj',
                pCutoff = 0.001,
                FCcutoff = 0.1,
                cutoffLineType = 'twodash',
                subtitle = "Co-DR-100nM vs S-100nM ",
                title = '',
                cutoffLineWidth = 0.8,
                pointSize = 2.0,
                labSize = 3.0,
                colAlpha = 1,
                legendLabels=c('Not sig.','log2FoldChange','padj',
                               'padj & log2FoldChange'),
                legendPosition = 'right',
                legendLabSize = 16,
                legendIconSize = 5.0)














# install.packages("pheatmap")
library(pheatmap)
# Data 
set.seed(123)
d<-read.csv("ETH_coef2x.csv", check.names = FALSE, row.names = 1)
d<-read.csv("ISR_DAdata23x_Rg_exposure_sp_selectedx2x.csv", check.names = FALSE, row.names = 1)
d<-read.csv("All_DAdata23x_Rg_exposure_sp40pairs.csv", check.names = FALSE, row.names = 1)

d<-read.csv("All_metabolite_Rg_exposure_sp_Revised2.csv", check.names = FALSE, row.names = 1)

d<-read.csv("ISR_metabolite_Rg_exposure_sp_Revisedx2top50.csv", check.names = FALSE, row.names = 1)

d<-read.csv("ETH_metabolite_Rg_exposure_sp_Revised2.csv", check.names = FALSE, row.names = 1)

d<-read.csv("All_Cytokine_Rg_exposure_sp_topassoction.csv", check.names = FALSE, row.names = 1)

d<-read.csv("AUC_comp.csv", check.names = FALSE, row.names = 1)

d<-read.csv("Pathway_AUC.csv", check.names = FALSE, row.names = 1)
d

d1<-as.matrix(d)



# Differential analysis heatmap in R 

png("Fig_Sp_cytokinecoef_ETH34.png", width=5, height=8, units="in", res=300)

png("AUC_path.png", width=8, height=8, units="in", res=300)

pheatmap(d1,cluster_rows= T, cluster_cols = F,legend=T,
                  display_numbers = round(d1,3),color = colorRampPalette(c("blue", "white", "red"))(50),
         number_color = "black", 
         fontsize_number = 8) 



dev.off()


library(pheatmap)
set.seed(1)
# to make cell narrow and space within the cells
rownames(d1) <- paste(rownames(d1))
png("Fig_ctytokine_Spcoef_R_ETH23.png", width=6, height=7, units="in", res=300)

pheatmap(d1,cellwidth = 50,cellheight = 10, cluster_rows= FALSE, cluster_cols = FALSE,legend=F,
         display_numbers = round(d1,6),color = colorRampPalette(c("blue", "white", "red"))(50),
         number_color = "black", 
         fontsize_number = 8) 

dev.off()












#Box plot analysis 
#Statistical tools        Primarily PERMANOVA, alpha diversity and the CLR transformation.
library(vegan)            #install.packages("vegan")
library(iNEXT)            #install.packages("iNEXT")
library(Tjazi)            #devtools::install_github("thomazbastiaanssen/Tjazi")

#Data Wrangling
library(tidyverse)        
library(knitr)            
library(waldo)          

#Plotting
library(ggplot2)          
library(ggforce)          
library(patchwork)        
library(ggbeeswarm)       
library(metafolio)  
library(factoextra)
library(FactoMineR)
library(vegan)




#allgroup
dx<-read.csv("OTU_PCA2.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("OTU_PCA2meta.csv", row.names = 1, check.names = FALSE)
# ETH-only
dx<-read.csv("OTU_ETH_asthma_control.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("metadata_ethio_only.csv", row.names = 1, check.names = FALSE)
dim(dt)
# ETH-ISR_asthmatic

dx<-read.csv("OTU_ETH_ISR_asthmatic.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("Sample_species_abundent_metadata.csv", row.names = 1, check.names = FALSE)
dim(dt)
#ETH-ISR_control
dx<-read.csv("OTU_ETH_ISR_Control.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("meta_ethioISRcontrol.csv", row.names = 1, check.names = FALSE)
dim(dt)
#ISR_asthma_control
dx<-read.csv("ISRonly_OTUx.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("ISR_meta.csv", row.names = 1, check.names = FALSE)
dim(dt)
dt$Group

head(dt)







dx

# Hellinger transformation
spc.dx1 <- decostand(dx, method = "total")
#Make into relative abundance
barsp   <- apply(dx, 2, function(i) i/sum(i)) 

#Define a cutoff for rare taxa in several steps:
#first, determine the max % abundance every feature ever shows up at 
maxa.sp <- apply(barsp, 1, max)
#Meanwhile, transpose the count table for future wrangling.
bar.sp<-data.frame(t(maxa.sp))
#For every sample, sum up all rare taxa ( < 1% at their highest in this case)
bar.sp$Rare.Taxa <- rowSums(bar.sp[,maxa.sp < 0.01], na.rm = TRUE)



#Remove the individual rare taxa now that they're summed up
bar.sp1 = bar.sp[,c(maxa.sp > 0.01, T) ] #`T` to include the `Rare Taxa`.  
dim(bar.sp1)





#Beta diversity
#make sure our count data is all numbers
sp<- apply(dx,c(1,2),function(x) as.numeric(as.character(x)))
#Remove features with prevalence < 10% in two steps:
#First, determine how often every feature is absent in a sample
n_zeroes <- rowSums(sp == 0)

#Then, remove features that are absent in more than your threshold (90% in this case).
sp<- sp[n_zeroes <= round(ncol(sp) * 0.90),]

#Perform a CLR transformation - #We are imputing zeroes using the 'const' method 
#Essentially, we replace zeroes with 65% of the next lowest value - see Lubbe et al 2021. 
sp.exp <- clr_c(sp)

#Apply the base R principal component analysis function on our CLR-transformed data.
data.a.pca  <- prcomp(t(sp.exp))

#Extract the amount of variance the first four components explain for plotting. 
pc1 <- round(data.a.pca$sdev[1]^2/sum(data.a.pca$sdev^2),4) * 100
pc2 <- round(data.a.pca$sdev[2]^2/sum(data.a.pca$sdev^2),4) * 100
pc3 <- round(data.a.pca$sdev[3]^2/sum(data.a.pca$sdev^2),4) * 100
pc4 <- round(data.a.pca$sdev[4]^2/sum(data.a.pca$sdev^2),4) * 100

#Extract the scores for every sample for the first four components for plotting. 
pca  = data.frame(PC1 = data.a.pca$x[,1], 
                  PC2 = data.a.pca$x[,2], 
                  PC3 = data.a.pca$x[,3], 
                  PC4 = data.a.pca$x[,4])

#Add relevant information from the metadata
pca$Group<-dt$Group
pca$Group
pca$Gender<-dt$Gender
pca$Age<-dt$Age

#First, the main plot. Plot the first two components of the PCA
mainbeta  <- ggplot(pca, aes(x       = PC1, 
                             y       = PC2, 
                             fill    = Group,
                             colour  = Group,
                             shape   = Group, 
                             group   = Group)) +  
  
  #Create the points and ellipses
  stat_ellipse(geom = "polygon", alpha = 1/4) +
  geom_point(size=3, col = "black") + 
  
  #Adjust appearance
  scale_fill_manual(values   = c("ISR-asthmatic" = "#FC4E07", "ISR-control" = "#00AFBB")) 
  
  #Adjust labels
  ggtitle("Main") + 
  xlab(paste("PC1: ", pc1,  "%", sep="")) + 
  ylab(paste("PC2: ", pc2,  "%", sep="")) + 
  theme_bw() 


  #c("#FC4E07", "#00AFBB"),
  #"#fe9929", "Ethio-control" = "#8c6bb1"


#Second, a smaller version to investigate the effect of sex. 
#Plot the first two components of the PCA
  pdf("pic_ETH-ISR_control.pdf", width=6, height=4) 
  
betad   <- ggplot(pca, aes(x       = PC1, 
                             y       = PC2, 
                             fill    = Group,
                             colour  = Group,
                             shape   = Group,
                             group   = Group)) +  
  
  #Create the points
  stat_ellipse(geom = "polygon", alpha = 1/4) +
  geom_point(size=2, col = "black")  

betad 

dev.off()






#PERMANOVA test


#Display NAs as empty space in the table to improve appearance.
options(knitr.kable.NA = "")

#Compute euclidean distance over CLR-transformed values (i.e. Aitchison distance).
dis_ait = dist(t(sp.exp), method = "euclidean")
#dis_ait = dist(t(sp.exp), method = "bray")



#Use the betadisper function to assess whether the groups have a difference in variance
beta_disp = betadisper(dis_ait, group = dt$Group)

#Check average aitchison distance from the centroid 
beta_disp$group.distances
#Run an ANOVA on the difference in variance per group, plot the results in a table
kable(anova(beta_disp), digits = 4)

#Perform a PERMANOVA (PERmutational Multivariate ANalysis Of VAriance) test.
PERMANOVA_res = adonis2(dis_ait ~ dt$Group + dt$Gender + dt$Age, 
                        data = dt, method = "euclidean", permutations = 1000)

#Plot the PERMANOVA results in a nice looking table
kable(PERMANOVA_res, digits = 4 )



#second methods


# Load the required packages
library(vegan)
library(phyloseq)
library(tidyverse)
library(patchwork)
library(agricolae)
library(FSA)
library(rcompanion)


dx <- phyloseq(OTU, TAX, samples)
dx

total = median(sample_sums(dx))
dx2 = function(x, t=total) round(t * (x / sum(x)))
dx3 = transform_sample_counts(dx, dx2)
dx3

dx4 = filter_taxa(dx3, function(x) sum(x > 2) > (0.11 * length(x)), TRUE) 
set.seed(10) # set seed for analysis reproducibility
OTU_filt_rar = rarefy_even_depth(otu_table(dx4), rngseed = TRUE, replace = FALSE) # rarefy the raw data using Phyloseq package
OTU_filt_rar

data_otu_filt_rar = data.frame(otu_table(OTU_filt_rar)) # create a separated file


# calculate Bray-Curtis distance using the vegan package
dist_bc <- as.matrix(vegdist(data_otu_filt_rar, method = "bray")) 
dist_bc

# Permanova test using the vegan package
adonis2(data_otu_filt_rar~samples_df$Groupx,data=samples_df, permutations=9999, method="bray")

# calculate Bray-Curtis distance using the vegan package
dist_bc <- as.matrix(vegdist(dx3, method = "bray")) 
dist_bc










data_dx = filter_taxa(dx, function(x) sum(x > 2) > (0.11 * length(x)), TRUE) 
set.seed(1782) # set seed for analysis reproducibility

# Pick the relative abundance table
dx<-read.csv("OTU_PCA2.csv", row.names = 1, check.names = FALSE)
dim(dx)
dt<-read.csv("OTU_PCA2meta.csv", row.names = 1, check.names = FALSE)
# Hellinger transformation
spc.dx1 <- decostand(dx, method = "total")


# calculate Bray-Curtis distance using the vegan package
dist_bc <- as.matrix(vegdist(spc.dx1, method = "bray")) 
dist_bc

# Calculates Bray-Curtis distances between samples. Because taxa is in
# columns, it is used to compare different samples. We transpose the
# assay to get taxa to columns
bray_curtis_dist <- vegan::vegdist(t(spc.dx1), method = "bray")

bray_curtis_dist
# PCoA
library(ecodist)
bray_curtis_pcoa <- ecodist::pco(bray_curtis_dist)
bray_curtis_pcoa$vectors
beta_disp



beta_disp$group.distances
#Run an ANOVA on the difference in variance per group, plot the results in a table
kable(anova(beta_disp), digits = 4)

#Perform a PERMANOVA (PERmutational Multivariate ANalysis Of VAriance) test.
PERMANOVA_res = adonis2(dis_ait ~ Groupx + Sex + Smoker, 
                        data = dt, method = "euclidean", permutations = 1000)

#Plot the PERMANOVA results in a nice looking table
kable(PERMANOVA_res, digits = 4 )


# Text Data 

# Load the required packages
library(vegan)
library(phyloseq)
library(tidyverse)
library(patchwork)
library(agricolae)
library(FSA)
library(rcompanion)
dx <- phyloseq(OTU, TAX, samples)
dx


dx
dxf = filter_taxa(dx, function(x) sum(x > 2) > (0.11 * length(x)), TRUE)

set.seed(1782)
OTU_filt_rar = rarefy_even_depth(otu_table(dxf), rngseed = TRUE, replace = FALSE) # rarefy the raw data using Phyloseq package
data_otu_filt_rar = data.frame(otu_table(OTU_filt_rar)) # create a separated file
data_phylo_filt_rar <- phyloseq(OTU_filt_rar, TAX, samples) # create a phyloseq object

data_phylo_filt_rar
# calculate Bray-Curtis distance using the vegan package
dist_bc <- as.matrix(vegdist(data_otu_filt_rar, method = "bray")) 
dist_bc
# a peek at the first five rows / columns
dist_bc[1:5, 1:5]

# calculate PCOA using Phyloseq package
pcoa_bc = ordinate(data_phylo_filt_rar, "PCoA", "bray") 

plot_ordination(data_phylo_filt_rar, pcoa_bc, color = "Groupx") + 
  geom_point(size = 3) 


df<-read.csv("microbimeSP_DMCs_ISR.csv", row.names = 1)
df2<-log10(df+1)
write.csv(df2, "microbimeSP_DMCs_ISRlog10.csv")

# bar plots 
library(ggpubr)
dt<-read.csv("AUC2.csv")
dt$ID
dt$AUC.for.LS.NL

library(ggplot2)

ggplot(dt, aes(x = dt$AUC, y = dt$ID, fill = dt$Group)) +
  geom_col(position = position_dodge())




p<-ggplot(dt, aes(x = dt$AUC, y = dt$ID, fill = dt$Group)) +
  geom_col(position = "dodge") + ggtitle("Discovery set") +
  xlab("AUC ") + ylab("Gene name") +
  
  geom_text(
    aes(label = AUC),
    colour = "black", size = 2,
    vjust = 0.3, position = position_dodge(0.8)
  )

# Modify legend titles
p + labs(fill = "AUC for")



p<-ggplot(dt, aes(x = dt$AUC2, y = dt$ID, fill = dt$Group)) +
  geom_col(position = "dodge") + ggtitle("Validation set") +
  xlab("AUC ") + ylab("") +
  
  geom_text(
    aes(label = AUC2),
    colour = "black", size = 1.5,
    vjust = 0.3, position = position_dodge(0.8)
  )

# Modify legend titles
p + labs(fill = "AUC for")



#xMWAS algorithms

install.packages("remotes")
remotes::install_github("kuppal2/xMWAS")
library(xMWAS)
# dependecies
library(mixOmics)
library(AnnotationDbi)
library(GO.db)
library(preprocessCore)
library(RBGL)
library(graph)



#load package
library(xMWAS)

#example dataset that includes metabolome, transcriptome, and cytokine data from the H1N1 mice study (Chandler 2016)
data(exh1n1)
#data(classlabels) #example classlabels file for case vs control design
#data(classlabels_repeatmeasures) #example classlabels file for repeat measures design
exh1n1
class(exh1n1)

xMat<-exh1n1$metabolome
yMat<-exh1n1$transcriptome
zMat<-exh1n1$cytokine
wMat<-NA
classlabels<-exh1n1$classlabels

#Code for reading tab-delimited text files as input data
#currently turned off:
if(FALSE)
{
  fname1<-"/Users/karanuppal/Downloads/OneDrive_1_11-3-2017/gene.txt"
  fname2<-"/Users/karanuppal/Downloads/OneDrive_1_11-3-2017/clinical.txt"
  fname3<-"/Users/karanuppal/Downloads/OneDrive_1_11-3-2017/metabolomics.txt"
  class_fname<-"/Users/karanuppal/Downloads/OneDrive_1_11-3-2017/Classfile.txt"
  xMat<-read.table(fname1,sep="\t",header=TRUE,row.names=1)
  yMat<-read.table(fname2,sep="\t",header=TRUE,row.names=1)
  zMat<-read.table(fname3,sep="\t",header=TRUE,row.names=1)
  classlabels<-read.table(class_fname,sep="\t",header=TRUE)
  xMat<-as.data.frame(xMat)
  yMat<-as.data.frame(yMat)
  zMat<-as.data.frame(zMat)
  wMat<-NA
}
###################

output<-"/Users/karanuppal/Downloads/xMWASv0.55output/" #change for your computer

#Please see user manual for description of arguments:
#https://github.com/kuppal2/xMWAS/blob/master/example_manual_tutorial/xMWAS-manual.pdf

#call the run_xmwas() function:
xmwas_res<-run_xmwas(Xome_data=xMat,Yome_data=yMat,Zome_data=zMat,Wome_data=NA,outloc=output,
                     classlabels=NA,class_fname=NA,xmwasmethod="pls",plsmode="regression",
                     max_xvar=10000, #e.g. select top 10000 of the variabels in X dataset based on relative standard deviation; change according to your dataset; you can also use proportion such as round(nrow(xMat)*0.3) to select top 30% of the variables.
                     max_yvar=10000, #select top 10000 of the variabels in Y dataset based on relative standard deviation;  change according to your dataset; you can also use proportion such as round(nrow(yMat)*0.3) to select top 30% of the variables.
                     max_zvar=10000, #select top 10000 variabels in Z dataset based on relative standard deviation;  change according to your dataset; you can also use proportion such as round(nrow(zMat)*0.3) to select top 30% of the variables.
                     max_wvar=10000, #select top 10000 variabels in W dataset based on relative standard deviation;  change according to your dataset; you can also use proportion such as round(nrow(wMat)*0.3) to select top 30% of the variables.
                     rsd.filt.thresh=1,
                     corthresh=0.4, #absolute correlation threshold
                     keepX=1000, #select up to top 1000 variables in the sPLS model; change according to your dataset
                     keepY=1000, #select up to top 1000 variables in the sPLS model; change according to your dataset
                     keepZ=1000, #select up to top 1000 variables in the sPLS model; change according to your dataset
                     keepW=1000, #select up to top 1000 variables in the sPLS model; change according to your dataset
                     pairedanalysis=FALSE, #set to TRUE if repeated measures study design
                     optselect=FALSE, #perform optimal PLS componenet selection; TRUE or FALSE; set to FALSE for exact Pearson correlation calculation using PLS regression
                     rawPthresh=0.05, #p-value threshold for correlation based on Student's t-test
                     numcomps=5, #max number of PLS components to use; set to N-1 (N: number of samples) for exact Pearson correlation calculation using PLS regression
                     net_edge_colors=c("blue","red"),
                     net_node_colors=c("orange", "green","cyan","pink"),
                     Xname="Metab", #change the name of dataset X
                     Yname="Gene", #change the name of dataset Y
                     Zname="Cytokine", #change the name of dataset Z
                     Wname="W", #change the name of dataset W
                     net_node_shape=c("square","circle","triangle","star"),
                     all.missing.thresh=0, #filter based on missing values: set to NA to turn it OFF; otherwise specify a value between: 0 to 1 (e.g. 0.8 to require that at least 80% of the samples have a non-missing value)
                     missing.val=0,
                     seednum=100,label.cex=0.2,vertex.size=6,
                     interactive=FALSE,max_connections=NA,
                     centrality_method="eigenvector", #centrality evaluation method
                     use.X.reference=FALSE,removeRda=TRUE,
                     compare.classes=FALSE, #compare classes: TRUE or FALSE
                     class.comparison.allvar=TRUE,
                     modularity.weighted=TRUE,
                     globalcomparison=TRUE,
                     plot.pairwise=FALSE, #plot results for pairwise comparisons: TRUE or FALSE
                     apply.sparse.class.comparison=FALSE, #perform variable selection in sPLS during class-wise comparison (default: FALSE)
                     layout.type="fr1")

suppressWarnings(try(sink(file=NULL),silent=TRUE))


#creat list data
mget( c("dt1","dt2","dt3") )


#outlier managment

# remove outlines above or below 3 standard deviation 
set.seed(123)

df<-read.csv("example.csv", row.names = 1)
df<-read.csv("wilcox_rank.csv", row.names = 1)

df<-read.csv("t_test.csv", row.names = 1)
df<-read.csv("DEG_AS80p.csv", row.names = 1)




df$ID2
library(dplyr)
library(ggplot2)
nudge <- 0.075

df |> 
  mutate(
    sig_label = case_when(
      padj < 0.001 ~ "***",
      padj < 0.01 ~ "**",
      padj < 0.05 ~ "*",
      padj >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge, log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.7,show.legend = T)+ theme_bw() + facet_wrap(~ ID2)+
  theme(axis.text.x = element_text(size =10, angle = 45, hjust = 1 , colour = "black")) +
  geom_text(aes(label = sig_label, y = label_position))


tiff("metabolite.tiff", units="in", width=5, height=5, res=300)

df$p.value
df$Wilcox.rank
df |> 
  mutate(
    sig_label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      p.value >= 0.05 ~ ""
    ),
    label_position = ifelse(Wilcox.rank > 0, Wilcox.rank + nudge, Wilcox.rank - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = Wilcox.rank , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.6,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black")) +
  geom_text(aes(label = sig_label, y = label_position))




dx<-read.csv("outwith80%data_EthioISR_asthmaControlx.csv", row.names = 1)
dx2<-log10(dx +1)
write.csv(dx2,"outwith80%data_EthioISR_asthmaControlxlog10.csv" )

df<-read.csv("t_test.csv", row.names = 1)
df<-read.csv("t_test_cytokine.csv", row.names = 1)

df<-read.csv("metabolite_FC.csv", row.names = 1)
df<-read.csv("Cytokine_FC_AUC.csv", row.names = 1)


df<-read.csv("metabolite_FC.csv", row.names = 1)


df$log2FC
df$Pvalue
df$ID2
df$Pvalue
png("metabolote_FC_final2.png", width=8, height=3, units="in", res=300)
colour

df |> 
  mutate(
    sig_label = case_when(
      Pvalue < 0.001 ~ "***",
      Pvalue < 0.01 ~ "**",
      Pvalue < 0.05 ~ "*",
      Pvalue >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge , log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.4,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
  geom_text(aes(y = label_position + 0.000005, label = sig_label)) + theme(axis.title.x = element_blank())


dev.off()

df<-read.csv("DEG_AS80p.csv", row.names = 1)
df$ID2
df$padj

png("AS.png", width=8, height=3, units="in", res=300)

df |> 
  mutate(
    sig_label = case_when(
      padj < 0.001 ~ "***",
      padj < 0.01 ~ "**",
      padj < 0.05 ~ "*",
      padj >= 0.05 ~ ""
    ),
    label_position = ifelse(log2FC > 0, log2FC + nudge , log2FC - nudge)
  ) |> 
  ggplot(aes(x =ID2 , y = log2FC , fill = ID2)) +
  geom_bar(stat = "identity" , width = 0.2,show.legend = F)+ theme_bw() + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
  geom_text(aes(y = label_position + 0.005, label = sig_label)) + theme(axis.title.x = element_blank())


dev.off()




# geom_text(aes(y=CIMax +0.01 , label=sig)

dfx<-read.csv("Normalized_metabolite_data.csv")
dfx<-read.csv("Asthma HSerum_Metabolites_Concentration_Norm_v01x2.csv")
library(reshape2)
library(ggplot2)
#library(lattice)
dfx$No
dfx$Group
dfx_log<-melt(dfx, id = "Group")
dfx_log$Group
dfx_log$variable
dfx_log$value
write.csv(dfx_log, "Normalized_metabolite_data_long.csv")

dfx_log<-read.csv("Normalized_metabolite_data_long.csv", row.names = 1)


summary(dfx_log$value)
# Change box plot colors by groups
xx<-ggplot(dfx_log, aes(x= variable, y= value, fill = Group, palette = "jco")) +
  geom_boxplot()


xx + theme(axis.text.x = element_text(size =5, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
  xlab(" ") + ylab("Metabolite log2(concentration) ") + scale_color_brewer(palette="Dark2")

#concentration/abundent
#palette = "npg"
library(ggpubr)

bxp <- ggboxplot(dfx_log, x = "variable", y = "value",
                 color = "Group", palette = "jco") 

#tiff("metabolite_concentration2x22.tiff",units="in", width=8, height=3, res=300)
png("cytokine-metabolite_intraction23x1.png", width=8, height=3, units="in", res=300)




bxp + theme(axis.text.x = element_text(size =6, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 6)) +
  xlab(" ") + ylab("Metabolite log2(concentration) ") 



dev.off()

dfx_log$Group[2]



library(palmerpenguins)
compare <- list(c("Control", "Asthmatic"))










library(ggplot2)
library(ggrepel)

data("mtcars")
df <- mtcars
df$cyl <- as.factor(df$cyl)

# Basic plot
# +++++++++++++++++++++++++++
ggscatter(df, x = "wt", y = "mpg",
          color = "black", shape = 21, size = 3, # Points color, shape and size
          add = "reg.line",  # Add regressin line
          add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
          conf.int = TRUE, # Add confidence interval
          cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
          cor.coeff.args = list(method = "pearson", label.x = 3, label.sep = "\n")
)


# Textual annotation
df$name <- rownames(df)
ggscatter(df, x = "wt", y = "mpg",
          color = "cyl", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          label = "name", repel = TRUE)


size=fontsize3
fontsize3 <- 7.5

R<-ggscatter(df, x = "wt", y = "mpg",
          color = "black", shape = 1, size = 1, # Points color, shape and size
          add = "reg.line",  # Add regressin line
          add.params = list(color = "gray", fill = "lightgray"), # Customize reg. line
          conf.int = T, # Add confidence interval
          cor.coef = TRUE,
          cor.coeff.args = list(method = "pearson", label.x = 3, label.sep = "\n"))

R 

# Add text annotations using ggplot2::geom_text
R + geom_text(aes(label = rownames(df)),
              size = 2)

# Use ggrepel::geom_text_repel
require("ggrepel")
set.seed(42)
R + geom_text_repel(aes(label = rownames(df)),
                    size = 2) 

# Use ggrepel::geom_label_repel and 
# Change color by groups
set.seed(42)
R + geom_label_repel(aes(label = rownames(df),
                         fill = factor(cyl)), color = 'white',
                     size = 1) +
  theme(legend.position = "bottom")






metsize(pilot = NULL, n1 = 6, n2 = 4, p = 100, prop = 0.1, covars = NULL,
        ncovar = 2, model = "PPCCA", plot.prop = FALSE, target.fdr = 0.05,
        Targeted = TRUE)


# regression and confidence interval plotting bar graph
df<-read.csv("metabolite_FCdata_exp.csv", row.names = 1)
df<-read.csv("Cytokine_FC_AUC.csv", row.names = 1)



df$Pvalue
df$CILow
df$CIMax
df$log2FC
df$ID2
library(ggsignif)
library(dplyr)
library(Seurat)
library(patchwork)
#confidence interval

df = df %>% 
  mutate(sig = case_when(Pvalue < 0.01 ~ "***",
                 Pvalue < 0.05 ~ "**",
                 Pvalue < 0.1 ~ "*",
                TRUE ~ ""))

  ggplot(df, aes(factor(ID2), AUC,  fill = ID2)) + 
   geom_bar(stat="identity", position = "dodge", show.legend = F) + 
  geom_errorbar(aes(ymin= AUC-CILow, ymax= AUC + CIMax), width=1, size=1,position="dodge") + 
  coord_flip() +  geom_text(aes(x=factor(ID2),y = AUC,label=sig),position = position_dodge(width=1)) 


  # regression coef and variable show barplot
  
  df = df %>% 
    mutate(sig = case_when(Pvalue < 0.01 ~ "***",
                           Pvalue < 0.05 ~ "**",
                           Pvalue < 0.1 ~ "*",
                           TRUE ~ ""))
  
  ggplot(df, aes(factor(ID2), AUC,  fill = ID2)) + 
    geom_bar(stat="identity", position = "dodge", show.legend = F) +
    theme_bw() + theme(axis.text.x = element_text(size =8, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 8)) +
    geom_errorbar(aes(ymin=CILow, ymax=CIMax), position=position_dodge(width=.9), width=.15) + 
    geom_text(aes(y=CIMax +0.01 , label=sig), position=position_dodge(width=.9)) + theme(axis.title.x = element_blank())  
    


  
  # regression coef and variable show barplot
   df$log2FC
  
   png("cytokine-FC22.png", width=7, height=2, units="in", res=300)
   
   
   df = df %>% 
    mutate(sig = case_when(Pvalue < 0.01 ~ "***",
                           Pvalue < 0.05 ~ "**",
                           Pvalue < 0.1 ~ "*",
                           TRUE ~ ""))
  
  ggplot(df, aes(factor(ID2), log2FC,  fill = ID2)) + 
    geom_bar(stat="identity", position = "dodge", show.legend = F) +
    theme_bw() + theme(axis.text.x = element_text(size =8, angle = 45, hjust = 1 , colour = "black"), axis.title.y = element_text(size = 10)) +
    geom_text(aes(y=log2FC +0.01 , label=sig), position=position_dodge(width=.1)) + theme(axis.title.x = element_blank())  
  
  
    dev.off()
  
  
  
  
  
  
  
  
  # clustering analysis 
  
  
  library(dplyr)
  library(Seurat)
  library(patchwork)
  
  # Load the PBMC dataset
  pbmc.data <- Read10X(data.dir = "/Users/desqz2/Desktop/Microbiome ETH research/singlecell/hg19")
  # Initialize the Seurat object with the raw (non-normalized data).
  pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
  pbmc
  
  dense.size <- object.size(as.matrix(pbmc.data))
  dense.size
  
  sparse.size <- object.size(pbmc.data)
  sparse.size
  dense.size/sparse.size
  #Standard pre-processing workflow
  pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
  # Visualize QC metrics as a violin plot
  VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
  
  # FeatureScatter is typically used to visualize feature-feature relationships, but can be used
  # for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
  
  plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
  plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
  plot1 + plot2
  
  pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
  pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
  pbmc <- NormalizeData(pbmc)
  #Identification of highly variable features (feature selection)
  
  pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
  
  # Identify the 10 most highly variable genes
  top10 <- head(VariableFeatures(pbmc), 10)
  
 
  pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
  
  # Identify the 10 most highly variable genes
  top10 <- head(VariableFeatures(pbmc), 10)
  
  # plot variable features with and without labels
  plot1 <- VariableFeaturePlot(pbmc)
  plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
  plot1 + plot2
  
  
  all.genes <- rownames(pbmc)
  pbmc <- ScaleData(pbmc, features = all.genes)
  
  pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
  
  # Examine and visualize PCA results a few different ways
  print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
  VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
  
DimPlot(pbmc, reduction = "pca") + NoLegend()

DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
ElbowPlot(pbmc)
 #Cluster the cells 
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5) 
pbmc <- RunUMAP(pbmc, dims = 1:10)
# individual clusters
DimPlot(pbmc, reduction = "umap")
# save output
saveRDS(pbmc, file = "../output/pbmc_tutorial.rds")

# find all markers of cluster 2
cluster2.markers <- FindMarkers(pbmc, ident.1 = 2)
head(cluster2.markers, n = 5)
# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3))
head(cluster5.markers, n = 5)
  
# find markers for every cluster compared to all remaining cells, report only the positive
# ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)
pbmc.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1)


cluster0.markers <- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))

# you can plot raw counts as well
VlnPlot(pbmc, features = c("NKG7", "PF4"), slot = "counts", log = TRUE)

FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
                               "CD8A"))

pbmc.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1) %>%
  slice_head(n = 10) %>%
  ungroup() -> top10
DoHeatmap(pbmc, features = top10$gene) + NoLegend()

new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
                     "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()

library(ggplot2)
plot <- DimPlot(pbmc, reduction = "umap", label = TRUE, label.size = 4.5) + xlab("UMAP 1") + ylab("UMAP 2") +
  theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + guides(colour = guide_legend(override.aes = list(size = 10)))
ggsave(filename = "../output/images/pbmc3k_umap.jpg", height = 7, width = 12, plot = plot, quality = 50)
saveRDS(pbmc, file = "../output/pbmc3k_final.rds")

#Canonical Correlation Analysis
require(ggplot2)
require(GGally)
require(CCA)
require(CCP)
install.packages("psychTools")
library(CCP)
library(CCA)
library(psych)
library(psychTools)
library(tidyverse)
data(mtcars)
library(vegan)
# Create and print the correlation matrix
(corr_matrix <- cor(mtcars))
cov(mtcars$mpg, mtcars$wt) / (sd(mtcars$mpg) * sd(mtcars$wt))

X <- mtcars %>%
  dplyr::select(-mpg, -qsec)

Y <- mtcars %>%
  dplyr::select(mpg, qsec)
library(CCA)
correl <- matcor(X, Y )
img.matcor(correl, type = 2)
# CCA the same both approaches 
cc1 <- cancor(X, Y) 
cc2 <- cc(X, Y) 

cc1$cor
cc2$cor

par(mfrow = c(1,1))
barplot(cc1$cor, main = "Canonical correlations for 'cancor()'", col = "gray")
barplot(cc1$cor, main = "Canonical correlations for 'cancor()'", col = "gray")
cc1$xcoef
cc2$xcoef
cc1$ycoef
cc2$ycoef
#maximized correlations between transformed vars of datasets from X & Y
plt.cc(cc2, var.label = TRUE, ind.names = mtcars[,1])
plt.cc(cc2)
cc2

library(vegan)
cc3 <- cca(X, Y)

plot(cc3, scaling = 1 )


plot(cc3, scaling = 1, var.label=F)


# CCA: Canonical correspondence analysis

# CCA constrained by the same environmental data
simpleCCA <- cca(mtcars$mpg ~., data= mtcars ) # Notice we are not using the hellinger transformation that downweights the importance of rare species
summary(simpleCCA)


# CCA Triplots
# Scaling 1: species scores scaled to relative eigenvalues, sites are weighted averages of the species  
plot(simpleCCA, scaling=1, display=c('species', 'wa', 'lc'), main='tiltle')

load("data/montastraea_species_matrix_vegan_harbornesites.Rdata") # mont.spec.matrix
load("data/montast_harbmeta_fullsite_shannon.Rdata") # shannon.montast.env.site
ls()


# libraries
library(tidyverse)
library(vegan)
library(ggvegan)
dt<-read.csv("cytokine-metabolite_intraction23_asthmaonly2.csv", row.names = 1)
dim(dt)
d1<-dt[,1:26]
d2<-dt[,27:30]

d1CCA <- cca(d1 ~ Isoleucine + Lactate + Methionine, data = d2) 
d1CCA                
plot(d1CCA)






??vegan

??cca
res.cc=cc(X,Y)
plt.cc(res.cc)
plt.cc(res.cc,d1=1,d2=3,var.label=TRUE)



data(varespec)
data(varechem)
## Common but bad way: use all variables you happen to have in your
## environmental data matrix
vare.cca <- cca(varespec, varechem )
vare.cca
plot(vare.cca, display=c("sp","cn"))
## Formula interface and a better model
vare.cca <- cca(varespec ~ Al + P*(K + Baresoil), data=varechem)
vare.cca
plot(vare.cca)
## `Partialling out' and `negative components of variance'
cca(varespec ~ Ca, varechem)
cca(varespec ~ Ca + Condition(pH), varechem)
## RDA
data(dune)
data(dune.env)
dune.Manure <- rda(dune ~ Manure, dune.env)
plot(dune.Manure) 


# netwrok analysis 
install.packages("igraph")
install.packages("igraphdata")
library(igraph)
library(igraphdata)
data(karate)
??igraph
dendrogram <- cluster_edge_betweenness(karate)

dendrogram
plot_dendrogram(dendrogram) # for hierarchical structure
membership(dendrogram) # best cut in terms of modularity
cut_at(dendrogram,no = 2) # cut into two groups

V(karate)[Faction == 1]$shape <- "circle"
V(karate)[Faction == 2]$shape <- "square"
set.seed(1)
plot(dendrogram,karate)
#optimal=cluster_optimal(karate)
#set.seed(1)
#plot(optimal,karate)
optimal_lg=cluster_fast_greedy(karate)
set.seed(1)
plot(optimal_lg,karate)

#Leading eigenvector
eigen=cluster_leading_eigen(karate)
set.seed(1)
plot(eigen,karate)


g <- sample_pa(100, m = 2, directed = FALSE)
eb <- cluster_edge_betweenness(g)

g <- make_full_graph(10) %du% make_full_graph(10)
g <- add_edges(g, c(1, 11))
eb <- cluster_edge_betweenness(g)
eb
g


## import the mixOmics library
library(mixOmics) 
set.seed(123) 
data(breast.TCGA) # load in the data
breast.TCGA$data.train$subtype

class(breast.TCGA)
# set a list of all the X dataframes
data = list(miRNA = breast.TCGA$data.train$mirna, 
            mRNA = breast.TCGA$data.train$mrna,
            proteomics = breast.TCGA$data.train$protein)

lapply(data, dim) # check their dimensions

# 
# load package microeco
#install.packages("microeco")
library(microeco)
??microec

library(microeco)
data(dataset)
data(env_data_16S)
dataset$otu_table
dataset$alpha_diversity
env_data_16S



dataset$sample_table <- data.frame(dataset$sample_table, env_data_16S[rownames(dataset$sample_table), ])
# extract two phyla to show the steps
d1 <- clone(dataset)
d1$tax_table <- d1$tax_table[d1$tax_table$Phylum == "p__Proteobacteria", ]
d1$tidy_dataset()
d1$cal_betadiv()
d2 <- clone(dataset)
d2$tax_table <- d2$tax_table[d2$tax_table$Phylum == "p__Bacteroidetes", ]
d2$tidy_dataset()
d2$cal_betadiv()



# first perform mantel test
t1 <- trans_env$new(dataset = d1, env_cols = 8:15)
t1$cal_mantel(use_measure = "bray", partial_mantel = TRUE)
t2 <- trans_env$new(dataset = d2, env_cols = 8:15)
t2$cal_mantel(use_measure = "bray", partial_mantel = TRUE)
# extract a part of the results 
x1 <- data.frame(spec = "Proteobacteria", t1$res_mantel) %>% .[, c(1, 3, 6, 8)]
x2 <- data.frame(spec = "Bacteroidetes", t2$res_mantel) %>% .[, c(1, 3, 6, 8)]
# rename columns
colnames(x1) <- colnames(x2) <- c("spec", "env", "r", "p.value")
# generate interval data
x1 %<>% dplyr::mutate(rd = cut(r, breaks = c(-Inf, 0.3, 0.6, Inf), labels = c("< 0.3", "0.3 - 0.6", ">= 0.6")),
                      pd = cut(p.value, breaks = c(-Inf, 0.01, 0.05, Inf), labels = c("< 0.01", "0.01 - 0.05", ">= 0.05")))
x2 %<>% dplyr::mutate(rd = cut(r, breaks = c(-Inf, 0.3, 0.6, Inf), labels = c("< 0.3", "0.3 - 0.6", ">= 0.6")),
                      pd = cut(p.value, breaks = c(-Inf, 0.01, 0.05, Inf), labels = c("< 0.01", "0.01 - 0.05", ">= 0.05")))







# cobine two tables
plot_table <- rbind(x1, x2)

install.packages("ggcor")

# install ggcor following the steps (https://chiliubio.github.io/microeco_tutorial/intro.html#github-packages)
library(ggplot2)

install.packages("ggcor")
source("https://raw.githubusercontent.com/briatte/ggcorr/master/ggcorr.R")

# install.packages("devtools")
devtools::install_github("houyunhuang/ggcor")


# install.packages("devtools")
devtools::install_github("houyunhuang/ggcor")




library(GGally)
library(ggcor)
set_scale()

g1 <- quickcor(t1$data_env, type = "upper", cor.test = TRUE, show.diag = FALSE) +
  geom_square() +
  geom_mark(sig.thres = 0.05, markonly = TRUE, color = "black", size = 6) +
  anno_link(aes(colour = pd, size = rd), data = plot_table) +
  scale_size_manual(values = c(0.5, 1.5, 3)) +
  scale_colour_manual(values = c("#D95F02", "#1B9E77", "#A2A2A288")) +
  guides(size = guide_legend(title = "Mantel's r", override.aes = list(colour = "grey35"), order = 2),
         colour = guide_legend(title = "Mantel's p", override.aes = list(size = 3), order = 1),
         fill = guide_colorbar(title = "Pearson's r", order = 3))

g1


# PCoA + boxplot

library(microeco)
library(magrittr)
library(ggplot2)
library(aplot)
theme_set(theme_bw())
data(dataset)
# PCoA
t1 <- trans_beta$new(dataset = dataset, group = "Group", measure = "bray")
t1$cal_ordination(ordination = "PCoA")
# extract the axis scores
tmp <- t1$res_ordination$scores
# differential test with trans_env class
t2 <- trans_env$new(dataset = dataset, add_data = tmp[, 1:2])
# 'KW_dunn' for non-parametric test
t2$cal_diff(group = "Group", method = "anova")



p1 <- t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
# groups order in p2 is same with p1; use legend.position = "none" to remove redundant legend
p2 <- t2$plot_diff(measure = "PCo1", add_sig = F) + theme_bw() + coord_flip() + 
  theme(legend.position = "none", axis.title.x = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank())
p3 <- t2$plot_diff(measure = "PCo2", add_sig = F) + theme_bw() + 
  theme(legend.position = "none", axis.title.y = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())
# height of the upper figure and width of the right-hand figure are both 0.2-fold of the main figure
g <- p1 %>% insert_top(p2, height = 0.2) %>% insert_right(p3, width = 0.2)
g

#14.8 FAPROTAX + differential test
library(tidyverse)                           
library(phyloseq)
library(edgeR)                                   
library(limma)                                    
library(DEFormats)                             
library(DESeq2)                                    
library(apeglm)                                
library(corncob) 
library(VennDiagram)
library(readxl)
library(apeglm)
library(microeco)
library(microeco)
library(magrittr)
set.seed(123)
library(ggplot2)
setwd("C:/Users/desqz2/Desktop/Abundence_Table/corncob/species")

#Asthmatic+control_All#Group

?microtable # how to creat dataset
# Asthma
otu_mat<-read.csv("OTU_species_abundance_allData3_outR.csv", row.names = 1)
tax_mat<-read.csv("Taxonomy_species_abundent.csv", row.names = 1)
samples_df<-read.csv("Sample_species_abundentData2x2_outR.csv", row.names = 1)
dim(samples_df)
dim(otu_mat)
write.csv()
mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)

# asthma-control_All
otu_mat<-read.csv("OTU_species_abundance_allData.kraken_assigned_reads2x.csv", row.names = 1)
tax_mat<-read.csv("Taxonomy_species_abundentx.csv", row.names = 1)
samples_df<-read.csv("Sample_species_abundentData2x2.csv", row.names = 1)
dim(samples_df)
dim(otu_mat)
dim(tax_mat)
row.names(samples_df)
colnames(otu_mat)
#x<-colnames(otu_mat)
#write.csv(x, "x.csv")

mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
mx$sample_table
tax_mat$Species

# write.csv(otu_mat,"Sample_species_abundentData2x.csv" )# id matching for both files 

# select top 8 abundant species
dim(otu_mat)
tax_mat$Species
tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 18)
tx$plot_bar(others_color = "grey70", facet = "Group", xtext_keep = FALSE, legend_text_italic = FALSE)


# The groupmean parameter can be used to obtain the group-mean barplot.

png("Group-Final.png", width=6, height=6, units="in", res=300)

tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 18, groupmean = "Group")
g1 <- tx$plot_bar(others_color = "brown", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 12))

dev.off()

#Diversity-based class
tr <- trans_alpha$new(dataset = mx, group = "Group")
tr$data_alpha$Measure

# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)

tr$plot_alpha(measure = "Shannon", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 6, boxplot_add = "jitter", order_x_mean = TRUE)
#Race

tr <- trans_alpha$new(dataset = mx, group = "Race")
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 4, boxplot_add = "jitter", order_x_mean = F)


# y_increase: increased height for each label
tr$plot_alpha(measure = "Chao1", shape = "Race", y_start = 0.1, y_increase = 0.1)

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "Chao1", boxplot_add = "dotplot", xtext_size = 10)
#trans_beta class

tr$data_alpha$Measure
tr <- trans_alpha$new(dataset = mx, group = "Race")

tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Shannon", shape = "Race")
# y_start: starting height for the first label
# y_increase: increased height for each label
tr$plot_alpha(measure = "Shannon", shape = "Race", y_start = 0.1, y_increase = 0.1)




#Diversity-based class
tr <- trans_alpha$new(dataset = mx, group = "Race")
# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Shannon", y_increase = 0.3)




# measure parameter must be one of names(dataset$beta_diversity)
tr <- trans_beta$new(dataset = mx, group = "Race", measure = "bray")

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "InvSimpson", boxplot_add = "dotplot", xtext_size = 15)


tr <- trans_alpha$new(dataset = mx, group = "Group", by_group = "Race")
tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Shannon")

tr <- trans_alpha$new(dataset = mx, group = "Group", by_group = "Race")
tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Chao1")






# PCoA, PCA, DCA and NMDS are available
tr$cal_ordination(ordination = "PCoA")
# t1$res_ordination is the ordination result list
class(t1$res_ordination)
# plot the PCoA result with confidence ellipse
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))






tr$cal_diff(method = "wilcox")


tr$cal_diff(method = "wilcox")
# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 6, boxplot_add = "jitter", order_x_mean = TRUE)




# create an trans_beta object
# measure parameter must be one of names(dataset$beta_diversity)
tr <- trans_beta$new(dataset = mx, group = "Group", measure = "bray")

# PCoA, PCA, DCA and NMDS are available
tr$cal_ordination(ordination = "PCoA")
# t1$res_ordination is the ordination result list
class(tr$res_ordination)
# plot the PCoA result with confidence ellipse
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))



#sub_correlation analysis in R

#Explainable class
library(microeco)
#asthma-control_All

otu_mat<-read.csv("OTU_species_abundance_allData.kraken_assigned_reads2x.csv", row.names = 1)
otu_mat<-log10(otu_mat + 1)
#write.csv(otu_mat,"OTU_species_abundance_allData.kraken_assigned_reads2xlog10.csv" )

tax_mat<-read.csv("Taxonomy_species_abundentx.csv", row.names = 1)
samples_df<-read.csv("Sample_species_abundentData2x2.csv", row.names = 1)
dim(samples_df)
dim(otu_mat)
dim(tax_mat)
row.names(samples_df)
colnames(otu_mat)
samples_df$Group
mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
#mx

write.csv(otu_mat,"OTU_species_abundance_allData.kraken_assigned_reads2x.csv")

dt_env<-read.csv("Asthma_control_metabolote_spx2_correlation_with_microbiome.csv", row.names = 1, check.names = F)

dt_env<-read.csv("Asthma_control_metabolote_spx2_corrsig.csv", row.names = 1, check.names = F)
dt_env<-read.csv("DMCs_bVals_final2_P_sigtop5000All2TFCorder.csv", row.names = 1, check.names = F)



dim(dt_env)
#getwd()



dim(dt_env)
colnames(dt_env)
row.names(dt_env)
# add_data is used to add the environmental data
#rx <- trans_env$new(dataset = mx, add_data = dt_env[, 1:10])
colnames(dt_env)
row.names(dt_env)
#more general ways 

new_testx <- clone(mx)
new_testx

new_testx$sample_table<- data.frame(new_testx$sample_table, dt_env[rownames(new_testx$sample_table), ])
# now new_test$sample_table has the whole data
new_testx

rx <- trans_env$new(dataset = new_testx, add_data = dt_env[, 1:5000])

# use Wilcoxon Rank Sum Test as an example
rx$cal_diff(group = "Group", method = "wilcox")
head(rx$res_diff)

rx$cal_diff(method = "wilcox", group = "Group")


rx$cal_diff(method = "wilcox", group = "Group")
# place all the plots into a list
tmp <- list()
for(i in colnames(rx$data_env)){
  tmp[[i]] <- rx$plot_diff(measure = i, add_sig_text_size = 2, xtext_size = 6, ytext_size = 2 ) + theme(plot.margin = unit(c(0.1, 0, 0, 1), "cm"))
}
plot(gridExtra::arrangeGrob(grobs = tmp, ncol = 3))

# require GGally package to be installed
rx$cal_autocor()
rx$cal_autocor(group = "Group")


# use bray-curtis distance for dbRDA
rx$cal_ordination(method = "dbRDA", use_measure = "bray")
# show the orginal results
rx$trans_ordination()
rx$plot_ordination(plot_color = "Group")
# the main results of RDA are related with the projection and angles between arrows
# adjust the length of the arrows to show them better
rx$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
# t1$res_rda_trans is the transformed result for plotting
rx$plot_ordination(plot_color = "Group")
rx$trans_ordination()
rx$res_ordination
summary(rx$res_ordination)

png("Group_AS_heatmap_cor_metabolitePCA2.png", width=5, height=5, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()

rx$cal_ordination_envfit()


# use Species # use for puplication
rx$cal_ordination(method = "RDA", taxa_level = "Species")
# select 10 features and adjust the arrow length
rx$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2)
# t1$res_rda_trans is the transformed result for plot
rx$plot_ordination(plot_color = "Group")


png("Group42_AS_heatmap_cor_metabolitePCAgroup2xfff.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()

rx$res_ordination_trans
summary(rx$res_ordination_trans)
rx$res_diff
rx$res_ordination_R2
rx$res_diff


# Correlation network analysis 


rx$plot_ordination(plot_color = "Group", plot_shape = "Group")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull", "centroid"), add_sample_label = " ")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "centroid", centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)



png("Group_AS_heatmap_cor_metabolitePCAgroup2_sigx.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)


dev.off()




rx$cal_mantel(use_measure = "bray")
# return t1$res_mantel
head(rx$res_mantel)
#correlation heatmap
dim(dt_env)
tx2 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:1000])
# 'p_adjust_type = "Env"' means p adjustment is performed for each environmental variable separately.
tx2$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "none")
tx2$cal_cor(use_data = "Species")

# default ggplot2 method with clustering
tx2$plot_cor()
# filter genera that donot have at least one ***
tx2$plot_cor(filter_feature = c(""))

png("Group_AS_heatmap_cor_metabolitePCAgroup2_sig.png", width=8, height=8, units="in", res=300)

tx2$plot_cor(filter_feature = c(""))

dev.off()



func1<-mx
func1$tidy_dataset()
# calculate abundance automatically at three levels: Level.1, Level.2, Level.3
func1$cal_abund()

func2 <- trans_diff$new(dataset = func1, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
func2$res_diff

png("Group-ETHmeanfinal_RF.png", width=6, height=6, units="in", res=300)
func2$plot_diff_bar(threshold = 0.9175042, width = 0.8)

dev.off()





#groupwaise correlation in R 

# first create trans_diff object as a demonstration # rf #lefse
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
t2$res_abund
t2$res_abund
mx$sample_table$Group



#model based (additional information to select biomarkers from rf and lefse model)

tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species", lefse_subgroup = NULL)
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
# we show 20 taxa with the highest LDA (log10)
tg$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))
# show part of the table
tg$res_diff[1:5, c(1, 3, 4, 6)]

tg$plot_diff_abund(use_number = 1:30, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


png("Group_AS_heatmap_cor_metabolitePCAgroup2_sigRFx.png", width=8, height=8, units="in", res=300)

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


dev.off()

# first create trans_diff object as a demonstration
tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species")





#correlationheatmap # puplication

# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:5000])
t1$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "Env")
# default ggplot2 method with clustering
t1$plot_cor( color_palette = col)

png("Group_AS_heatmap_cor2xx2x2.png", width=12, height=5, units="in", res=300)

t1$plot_cor(color_palette = col)

dev.off()

# filter genera that donot have at least one ***
t1$plot_cor(filter_feature = c(""))
#important taxa detected in the biomarker analysis

mx$sample_table
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2$res_diff
# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:5000])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:8])
t1$res_cor  
t1$plot_cor()         

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor(pheatmap = TRUE)

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:21])
# return t1$res_cor
t1$plot_cor(pheatmap = TRUE )

xx<-t1$res_cor
write.csv(xx, "resultcorrelation_DNACpG_5000_All.csv")
xx





# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)

t1$plot_cor()


png("AS2_ETH_heatmap_cor2xx2xgroupx21d13x_RFx2.png", width=12, height=4, units="in", res=300)

t1$plot_cor(color_palette = col,xtext_angle = 75, xtext_size = 8)

dev.off()






png("Group_AS_heatmap_cor2.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = F )

dev.off()

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = T )

dev.off()




dim(t2$res_abund) #P.unadj #P.adj

# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:40])
t1$data_env
# use other_taxa to select taxa you need # fdr

#holm, hochberg, hommel, bonferroni, BH, BY, fdr, none

t1$cal_cor(use_data = "other", p_adjust_method = "none",other_taxa = t2$res_diff$Taxa)
t1$plot_cor()

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor() 
 g1<-t1$plot_cor()
 g1 + theme(axis.title.x = element_text(size = 0.4))
 
 

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)

png("Group_AS_heatmap_cor2xRF_group.png", width=20, height=5, units="in", res=300)

t1$plot_cor(color_palette = col )

dev.off()




# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
dim(t2)
x<-t2$res_diff
write.csv(x, "rf.ETH.csv")

# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2


# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:1000])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:10])
t1$res_cor  
t1$plot_cor()         

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:21])
# return t1$res_cor
t1$plot_cor(pheatmap = TRUE, color_palette = col )

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)

t1$plot_cor(color_palette = col)

png("Group_ISR_ETH_heatmap_cor2xx2xgroupx21d13_RFx2.png", width=12, height=4, units="in", res=300)
t1$plot_cor(color_palette = col,xtext_angle = 75, xtext_size = 6)
dev.off()



































#ISR_ETH_control analysis 
# ISR_ETH_asthmatic only analysis


getwd()
#plot asthmatic_ETH_ISR
#Differentially methylated genes
otu_mat<- read.csv("OTU_species_abundance_EthioISR_asthmatic2x.csv", row.names = 1)
otu_mat<-log10(otu_mat + 1)
tax_mat<- read.csv("Taxonomy_species_abundent_EthioISR_asthmatic2x.csv", row.names = 1)
samples_df <- read.csv("Sample_species_abundent_metadatax.csv", row.names = 1)
samples_df

dim(samples_df)
dim(otu_mat)
dim(tax_mat)
row.names(samples_df)
colnames(otu_mat)
f<-colnames(otu_mat)
write.csv(f, "fx.csv")# matching the Ids in the columbs and rows 

mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
mx

mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
#mx

dt_env<-read.csv("SP_methabolite_Ethio_ISR_asthmatic.csv", row.names = 1, check.names = F)

dt_env<-read.csv("SP_methabolite_Ethio_ISR_asthmatic_cor.csv", row.names = 1, check.names = F)
dim(dt_env)
#getwd()








# select top 8 abundant species 
samples_df$Group
tax_mat$Species
tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 10)
tx$plot_bar(others_color = "grey70", facet = "Group", xtext_keep = FALSE, legend_text_italic = FALSE)


# The groupmean parameter can be used to obtain the group-mean barplot.

png("Group-mean barplot_ETH_ISR_asthmatic.png", width=6, height=4, units="in", res=300)

tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 15, groupmean = "Group")
g1 <- tx$plot_bar(others_color = "brown", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 14))

dev.off()

#Diversity-based class
tr <- trans_alpha$new(dataset = mx, group = "Group")
tr$data_alpha

# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 6, boxplot_add = "jitter", order_x_mean = TRUE)
#Race
tr <- trans_alpha$new(dataset = mx, group = "Race")
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 4, boxplot_add = "jitter", order_x_mean = F)


# y_increase: increased height for each label
tr$plot_alpha(measure = "Chao1", shape = "Group", y_start = 0.1, y_increase = 0.1)

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "Chao1", boxplot_add = "dotplot", xtext_size = 10)
#trans_beta class
# measure parameter must be one of names(dataset$beta_diversity)
tr <- trans_beta$new(dataset = mx, group = "Group", measure = "bray")








# PCoA, PCA, DCA and NMDS are available
tr$cal_ordination(ordination = "PCoA")
# t1$res_ordination is the ordination result list
class(t1$res_ordination)
# plot the PCoA result with confidence ellipse
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))






tr$cal_diff(method = "wilcox")


tr$cal_diff(method = "wilcox")
# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment



dim(dt_env)
colnames(dt_env)
#getwd()
dt_env


dim(dt_env)
colnames(dt_env)
row.names(dt_env)
# add_data is used to add the environmental data
#rx <- trans_env$new(dataset = mx, add_data = dt_env[, 1:10])
colnames(dt_env)
row.names(dt_env)
#more general ways 

new_testx <- clone(mx)
new_testx

new_testx$sample_table<- data.frame(new_testx$sample_table, dt_env[rownames(new_testx$sample_table), ])
# now new_test$sample_table has the whole data
new_testx

rx <- trans_env$new(dataset = new_testx, add_data = dt_env[, 1:43])

# use Wilcoxon Rank Sum Test as an example
rx$cal_diff(group = "Group", method = "wilcox")
head(rx$res_diff)

rx$cal_diff(method = "wilcox", group = "Group")


rx$cal_diff(method = "wilcox", group = "Group")
# place all the plots into a list
tmp <- list()
for(i in colnames(rx$data_env)){
  tmp[[i]] <- rx$plot_diff(measure = i, add_sig_text_size = 2, xtext_size = 6, ytext_size = 2 ) + theme(plot.margin = unit(c(0.1, 0, 0, 1), "cm"))
}
plot(gridExtra::arrangeGrob(grobs = tmp, ncol = 3))

# require GGally package to be installed
rx$cal_autocor()
rx$cal_autocor(group = "Group")


# use bray-curtis distance for dbRDA
rx$cal_ordination(method = "dbRDA", use_measure = "bray")
# show the orginal results
rx$trans_ordination()
rx$plot_ordination(plot_color = "Group")
# the main results of RDA are related with the projection and angles between arrows
# adjust the length of the arrows to show them better
rx$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
# t1$res_rda_trans is the transformed result for plotting
rx$plot_ordination(plot_color = "Group")

png("Group_AS_heatmap_cor_metabolitePCA2_ISR.png", width=5, height=5, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()

rx$cal_ordination_envfit()


# use Species # use for puplication
rx$cal_ordination(method = "RDA", taxa_level = "Species")
# select 10 features and adjust the arrow length
rx$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2)
# t1$res_rda_trans is the transformed result for plot
rx$plot_ordination(plot_color = "Group")
mx$sample_table$Group

png("Group_AS_heatmap_ISR_ETH_AS_RDA.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()


# Correlation network analysis 

rx$plot_ordination(plot_color = "Group", plot_shape = "Group")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull", "centroid"), add_sample_label = " ")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "centroid", centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)



png("Group_AS_heatmap_cor_metabolitePCAgroup2_sigx.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)


dev.off()

rx$cal_mantel(use_measure = "bray")
# return t1$res_mantel
head(rx$res_mantel)
#correlation heatmap
dim(dt_env)
tx2 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:22])
# 'p_adjust_type = "Env"' means p adjustment is performed for each environmental variable separately.
tx2$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "none")
tx2$cal_cor(use_data = "Species")

# default ggplot2 method with clustering
tx2$plot_cor()
# filter genera that donot have at least one ***
tx2$plot_cor(filter_feature = c(""))

png("Group_AS_heatmap_cor_metabolitePCAgroup2_sig.png", width=8, height=8, units="in", res=300)

tx2$plot_cor(filter_feature = c(""))

dev.off()


#groupwaise correlation in R 

# first create trans_diff object as a demonstration # rf #lefse
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
t2$res_abund
t2$res_abund
mx$sample_table$Group


#model based (additional information to select biomarkers from rf and lefse model)

tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species", lefse_subgroup = NULL)
mx$sample_table$Group

f<-tg$res_diff
write.csv(f, "ISR_ETH_RF.csv")


# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
# we show 20 taxa with the highest LDA (log10)
tg$plot_diff_bar(use_number = 1:26, width = 0.8, group_order = c("ETH-asthmatic", "ISR-asthmatic"))
# show part of the table
tg$res_diff[1:5, c(1, 3, 4, 6)]

tg$plot_diff_abund(use_number = 1:26, group_order = c("ETH-asthmatic", "ISR-asthmatic"))

tg$plot_diff_abund(use_number = 1:26, add_sig = T, add_sig_label = "Significance")



png("Group_AS_heatmap_cor_ETH_ISR_RF2x.png", width=8, height=8, units="in", res=300)

tg$plot_diff_abund(use_number = 1:26, add_sig = T, add_sig_label = "Significance")


dev.off()

# first create trans_diff object as a demonstration
tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species")





#correlationheatmap # puplication
dim(dt_env)
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:43])
t1$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "Env")
# default ggplot2 method with clustering
t1$plot_cor(show_column_names = F)

png("Group_AS_heatmap_cor2xx2x_ISR.png", width=25, height=5, units="in", res=300)

t1$plot_cor(color_palette = col)

dev.off()




# filter genera that donot have at least one ***
t1$plot_cor(filter_feature = c(""))
#important taxa detected in the biomarker analysis


mx$sample_table

# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:43])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:26])
t1$res_cor  
t1$plot_cor()         

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor(pheatmap = TRUE, color_palette = col)
col<- colorRampPalette(c("blue", "white", "red"))(20)
#col=colorRampPalette(c("blue","white","red"))(20)




# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:26])
# return t1$res_cor
t1$plot_cor(pheatmap = TRUE, color_palette = col )
t1$plot_cor(pheatmap = TRUE, color_palette = col, xtext_keep = F)
t1$plot_cor(xtext_size = 4, color_palette = col)



mx$sample_table$Group
xxr<-t1$res_cor
write.csv(xxr, "resultcorrelationRFmicrbiome_metabolite_ETH_ISRx.csv")


# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)

t1$plot_cor(color_palette = col)






png("Group_ISR_ETH_heatmap_cor2xx2xgroupx21d13_RFx2.png", width=12, height=4, units="in", res=300)
t1$plot_cor(xtext_size = 4, color_palette = col)



dev.off()
t1$plot_cor()





png("Group_AS_heatmap_cor2.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = F )

dev.off()

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = T )

dev.off()




dim(t2$res_abund) #P.unadj #P.adj

# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:40])
t1$data_env
# use other_taxa to select taxa you need # fdr

#holm, hochberg, hommel, bonferroni, BH, BY, fdr, none

t1$cal_cor(use_data = "other", p_adjust_method = "none",other_taxa = t2$res_diff$Taxa)
t1$plot_cor()

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor() 
g1<-t1$plot_cor()
g1 + theme(axis.title.x = element_text(size = 0.4))



# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)















































# ETH analysis only 

otu_mat<- read.csv("OTU_Ethi0_only_species_abundetData_DAA.csv", row.names = 1)
otu_mat<-log10(otu_mat + 1)
#write.csv(otu_mat,"OTU_Ethi0_only_species_abundetData_DAAlog10.csv" )


tax_mat<- read.csv("Taxonomy_species_abundent_Ethio_only_asthmatic_DAA.csv", row.names = 1)
samples_df <- read.csv("metadata_ethio_onlyx.csv", row.names = 1)
samples_df

dim(samples_df)
dim(otu_mat)
dim(tax_mat)
row.names(samples_df)
colnames(otu_mat)
x1<-colnames(otu_mat)
#write.csv(x1,"x1EtH.csv")




mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)

# select top 8 abundant species 
samples_df$Race
tax_mat$Species
tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 20)
tx$plot_bar(others_color = "grey70", facet = "Group", xtext_keep = FALSE, legend_text_italic = FALSE)


# The groupmean parameter can be used to obtain the group-mean barplot.

png("Group-meanfinal.png", width=6, height=6, units="in", res=300)

tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 18, groupmean = "Group")
g1 <- tx$plot_bar(others_color = "brown", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 14))

dev.off()

#Diversity-based class
tr <- trans_alpha$new(dataset = mx, group = "Group")
tr$data_alpha

# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 6, boxplot_add = "jitter", order_x_mean = TRUE)
#Race
tr <- trans_alpha$new(dataset = mx, group = "Race")
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
tr$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 4, boxplot_add = "jitter", order_x_mean = F)


# y_increase: increased height for each label
tr$plot_alpha(measure = "Chao1", shape = "Group", y_start = 0.1, y_increase = 0.1)

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "Chao1", boxplot_add = "dotplot", xtext_size = 10)
#trans_beta class
# measure parameter must be one of names(dataset$beta_diversity)

dt_env<-read.csv("SP_methabolite_Ethio2.csv", row.names = 1, check.names = F)
dt_env<-read.csv("SP_methabolite_Ethio2x.csv", row.names = 1, check.names = F)
dt_env<-read.csv("SP_methabolite_Ethio2cor.csv", row.names = 1, check.names = F)

dt_env<-read.csv("SP_methabolite_Ethio2x.csv", row.names = 1, check.names = F)
dt_env<-read.csv("CpG_gut_micrbiome.csv", row.names = 1, check.names = F)
dt_env<-read.csv("CpG_gut_micrbiomecor.csv", row.names = 1, check.names = F)
dt_env<-read.csv("DMCs_bVals_final2_P_sigtop5000_ETH_T.csv", row.names = 1, check.names = F)




dim(dt_env)
colnames(dt_env)

dim(dt_env)
colnames(dt_env)
row.names(dt_env)
# add_data is used to add the environmental data
#rx <- trans_env$new(dataset = mx, add_data = dt_env[, 1:10])
colnames(dt_env)
row.names(dt_env)
#more general ways 

new_testx <- clone(mx)
new_testx

new_testx$sample_table<- data.frame(new_testx$sample_table, dt_env[rownames(new_testx$sample_table), ])
# now new_test$sample_table has the whole data
new_testx

rx <- trans_env$new(dataset = new_testx, add_data = dt_env[, 1:43])

# use Wilcoxon Rank Sum Test as an example
rx$cal_diff(group = "Group", method = "wilcox")
head(rx$res_diff)

rx$cal_diff(method = "wilcox", group = "Group")


rx$cal_diff(method = "wilcox", group = "Group")
# place all the plots into a list
tmp <- list()
for(i in colnames(rx$data_env)){
  tmp[[i]] <- rx$plot_diff(measure = i, add_sig_text_size = 2, xtext_size = 6, ytext_size = 2 ) + theme(plot.margin = unit(c(0.1, 0, 0, 1), "cm"))
}
plot(gridExtra::arrangeGrob(grobs = tmp, ncol = 3))

# require GGally package to be installed
rx$cal_autocor()
rx$cal_autocor(group = "Group")


# use bray-curtis distance for dbRDA
rx$cal_ordination(method = "dbRDA", use_measure = "bray")
# show the orginal results
rx$trans_ordination()
rx$plot_ordination(plot_color = "Group")
# the main results of RDA are related with the projection and angles between arrows
# adjust the length of the arrows to show them better
rx$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
# t1$res_rda_trans is the transformed result for plotting
rx$plot_ordination(plot_color = "Group")

png("Group_AS_heatmap_cor_metabolitePCA2_ISR.png", width=5, height=5, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()

rx$cal_ordination_envfit()


# use Species # use for puplication
rx$cal_ordination(method = "RDA", taxa_level = "Species")
# select 10 features and adjust the arrow length
rx$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2)
# t1$res_rda_trans is the transformed result for plot
rx$plot_ordination(plot_color = "Group")


png("Group_AS_heatmap_ETH_RDA2x2.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()


# Correlation network analysis 


rx$plot_ordination(plot_color = "Group", plot_shape = "Group")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull", "centroid"), add_sample_label = " ")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "centroid", centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)



png("Group_AS_heatmap_cor_metabolitePCAgroup2_sigx.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)


dev.off()


rx$cal_mantel(use_measure = "bray")
# return t1$res_mantel
head(rx$res_mantel)
#correlation heatmap
dim(dt_env)
tx2 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:11])
# 'p_adjust_type = "Env"' means p adjustment is performed for each environmental variable separately.
tx2$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "none")
tx2$cal_cor(use_data = "Species")

# default ggplot2 method with clustering
tx2$plot_cor()
# filter genera that donot have at least one ***
tx2$plot_cor(filter_feature = c(""), color_palette = col)

png("Group_AS_heatmap_cor_metabolitePCAgroup2_sig.png", width=8, height=8, units="in", res=300)

tx2$plot_cor(filter_feature = c(""))

dev.off()


#groupwaise correlation in R 

# first create trans_diff object as a demonstration # rf #lefse
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
t2$res_abund
t2$res_abund
mx$sample_table$Group


#model based (additional information to select biomarkers from rf and lefse model)

tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species", lefse_subgroup = NULL)
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
# we show 20 taxa with the highest LDA (log10)
mx$sample_table$Group
tg$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("ETH-asthmatic", "ETH-control"))
# show part of the table
tg$res_diff[1:5, c(1, 3, 4, 6)]

tg$plot_diff_abund(use_number = 1:30, group_order = c("ETH-asthmatic", "ETH-control"))

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


png("Group_AS_heatmap_cor_ETH2x_RF2.png", width=8, height=8, units="in", res=300)

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


dev.off()

# first create trans_diff object as a demonstration
tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species")





#correlationheatmap # puplication
dim(dt_env)
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:11])
t1$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "Env")
# default ggplot2 method with clustering
t1$plot_cor()

t1$cal_cor(by_group = "Group", use_data = "Species", p_adjust_method = "none", p_adjust_type = "Env")
# return t1$res_cor

t1$plot_cor(color_palette = col)






png("Group_AS_heatmap_cor2xx2x_ISR.png", width=25, height=5, units="in", res=300)

t1$plot_cor(color_palette = col)

dev.off()


# filter genera that donot have at least one ***
t1$plot_cor(filter_feature = c(""))
#important taxa detected in the biomarker analysis


mx$sample_table

# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:7])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:10])
t1$res_cor  
t1$plot_cor(color_palette = col)         




func1<-mx
func1$tidy_dataset()
# calculate abundance automatically at three levels: Level.1, Level.2, Level.3
func1$cal_abund()

func2 <- trans_diff$new(dataset = func1, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
func2$res_diff

png("Group-ETHmeanfinal_RF.png", width=6, height=6, units="in", res=300)
func2$plot_diff_bar(threshold = 0.4840003, width = 0.8)

dev.off()











#without Rf

# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:5000])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:10])
t1$res_cor  
t1$plot_cor(color_palette = col)         

png("Group_AS_heatmap_cor2_group_RFx_cor23.png", width=15, height=4, units="in", res=300)

t1$plot_cor(color_palette = col)   

dev.off()

t1$plot_cor(color_palette = col, unit(c(1,1,1), "cm"))   
#c(bottom, left, top, right)
par(mai = c(1.5, 1.5, 1.5, 1.5))
par(oma = c(4, 10, 4, 4))
t1$plot_cor(color_palette = col)   



# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
# calculate correlations for different groups using parameter by_group


t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:10])
# return t1$res_cor
t1$plot_cor()
t1$plot_cor(color_palette = col)

xf<-t1$res_cor
xf
write.csv(xf, "cor_ETH_cpg-micrbiome_5000.csv")


png("Group_ETH_heatmap_cor2CPG.png", width=15, height=4, units="in", res=300)

t1$plot_cor(color_palette = col,xtext_angle = 75, xtext_size = 4)

dev.off()

getwd()






png("Group_AS_heatmap_cor2.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = F )

dev.off()

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = T )

dev.off()


dim(t2$res_abund) #P.unadj #P.adj

# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:5000])
t1$data_env
# use other_taxa to select taxa you need # fdr

#holm, hochberg, hommel, bonferroni, BH, BY, fdr, none

t1$cal_cor(use_data = "other", p_adjust_method = "none",other_taxa = t2$res_diff$Taxa)
t1$plot_cor()

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor() 
t1$plot_cor(color_palette = col,xtext_size = 4, ytext_size = 4)








#
trans_abund$plot_heatmap(
  color_values = rev(RColorBrewer::brewer.pal(n = 11, name = "RdYlBu")),
  facet = NULL,
  x_axis_name = NULL,
  order_x = NULL,
  withmargin = TRUE,
  plot_numbers = FALSE,
  plot_text_size = 4,
  plot_breaks = NULL,
  margincolor = "white",
  plot_colorscale = "log10",
  min_abundance = 0.01,
  max_abundance = NULL,
  strip_text = 11,
  xtext_size = 10,
  ytext_size = 11,
  xtext_keep = TRUE,
  xtitle_keep = TRUE,
  grid_clean = TRUE,
  xtext_angle = 0,
  legend_title = "% Relative\nAbundance",
  pheatmap = FALSE,
  ...
)

#


# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)
























# ISR data analysis 
#Differentially methylated genes
otu_mat<-read.csv("ISRonly_OTU_DAAx.csv", row.names = 1)
otu_mat<-log10(otu_mat + 1)
tax_mat<-read.csv("ISR_taxrankx.csv", row.names = 1)
samples_df<-read.csv("ISR_metax.csv", row.names = 1)
dim(samples_df)
dim(otu_mat)
dim(tax_mat)
row.names(samples_df)
colnames(otu_mat)
x1<-colnames(otu_mat)
#write.csv(x1,"x1.csv")
mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
#mx
dt_env<-read.csv("SP_metbolic_ISR_only.csv", row.names = 1, check.names = F)
dt_env<-read.csv("SP_metbolic_ISR_onlySig.csv", row.names = 1, check.names = F)
dt_env<-read.csv("SP_metbolic_ISR_onlySig_asthmatic.csv", row.names = 1, check.names = F)
dt_env<-read.csv("DMCs_bVals_final2_P_sigtop5000_ISR_T.csv", row.names = 1, check.names = F)

mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)


dim(dt_env)
colnames(dt_env)
#getwd()



dim(dt_env)
colnames(dt_env)
row.names(dt_env)
# add_data is used to add the environmental data
#rx <- trans_env$new(dataset = mx, add_data = dt_env[, 1:10])
colnames(dt_env)
row.names(dt_env)
#more general ways 

new_testx <- clone(mx)
new_testx

new_testx$sample_table<- data.frame(new_testx$sample_table, dt_env[rownames(new_testx$sample_table), ])
# now new_test$sample_table has the whole data
new_testx

rx <- trans_env$new(dataset = new_testx, add_data = dt_env[, 1:23])

# use Wilcoxon Rank Sum Test as an example
rx$cal_diff(group = "Group", method = "wilcox")
head(rx$res_diff)

rx$cal_diff(method = "wilcox", group = "Group")


rx$cal_diff(method = "wilcox", group = "Group")
# place all the plots into a list
tmp <- list()
for(i in colnames(rx$data_env)){
  tmp[[i]] <- rx$plot_diff(measure = i, add_sig_text_size = 2, xtext_size = 6, ytext_size = 2 ) + theme(plot.margin = unit(c(0.1, 0, 0, 1), "cm"))
}
plot(gridExtra::arrangeGrob(grobs = tmp, ncol = 3))

# require GGally package to be installed
rx$cal_autocor()
rx$cal_autocor(group = "Group")


# use bray-curtis distance for dbRDA
rx$cal_ordination(method = "dbRDA", use_measure = "bray")
# show the orginal results
rx$trans_ordination()
rx$plot_ordination(plot_color = "Group")
# the main results of RDA are related with the projection and angles between arrows
# adjust the length of the arrows to show them better
rx$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
# t1$res_rda_trans is the transformed result for plotting
rx$plot_ordination(plot_color = "Group")

png("Group_AS_heatmap_cor_metabolitePCA2_ISR.png", width=5, height=5, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()

rx$cal_ordination_envfit()


# use Species # use for puplication
rx$cal_ordination(method = "RDA", taxa_level = "Species")
# select 10 features and adjust the arrow length
rx$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2)
# t1$res_rda_trans is the transformed result for plot
rx$plot_ordination(plot_color = "Group")


png("Group_AS_heatmap_ISR_RDA2.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group")

dev.off()





# Correlation network analysis 


rx$plot_ordination(plot_color = "Group", plot_shape = "Group")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse", "centroid"))
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull", "centroid"), add_sample_label = " ")
rx$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "centroid", centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)



png("Group_AS_heatmap_cor_metabolitePCAgroup2_sigx.png", width=8, height=8, units="in", res=300)

rx$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)


dev.off()




rx$cal_mantel(use_measure = "bray")
# return t1$res_mantel
head(rx$res_mantel)
#correlation heatmap
dim(dt_env)
tx2 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:23])
# 'p_adjust_type = "Env"' means p adjustment is performed for each environmental variable separately.
tx2$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "none")
tx2$cal_cor(use_data = "Species")

# default ggplot2 method with clustering
tx2$plot_cor()
# filter genera that donot have at least one ***
tx2$plot_cor(filter_feature = c(""))

png("Group_AS_heatmap_cor_metabolitePCAgroup2_sig.png", width=8, height=8, units="in", res=300)

tx2$plot_cor(filter_feature = c(""))

dev.off()


# analysis

png("Group-ISRmeanfinal.png", width=6, height=6, units="in", res=300)

tx <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 18, groupmean = "Group")
g1 <- tx$plot_bar(others_color = "brown", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 14))

dev.off()


func1
func1<-mx
func1$tidy_dataset()
# calculate abundance automatically at three levels: Level.1, Level.2, Level.3
func1$cal_abund()

func2 <- trans_diff$new(dataset = func1, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
func2$res_diff

png("Group-ISRmeanfinal_RF.png", width=6, height=6, units="in", res=300)
func2$plot_diff_bar(threshold = 0.1329231, width = 0.8)

dev.off()





#groupwaise correlation in R 

# first create trans_diff object as a demonstration # rf #lefse
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "Species", p_adjust_method = "none")
t2$res_abund
t2$res_abund
mx$sample_table$Group



#model based (additional information to select biomarkers from rf and lefse model)

tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species", lefse_subgroup = NULL)
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
# we show 20 taxa with the highest LDA (log10)
tg$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("ISR-asthmatic", "ISR-control"))
# show part of the table
tg$res_diff[1:5, c(1, 3, 4, 6)]

tg$plot_diff_abund(use_number = 1:30, group_order = c("ISR-asthmatic", "ISR-control"))

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


png("RF_heatmap_cor_ISR_RF2.png", width=8, height=8, units="in", res=300)

tg$plot_diff_abund(use_number = 1:30, add_sig = T, add_sig_label = "Significance")


dev.off()

# first create trans_diff object as a demonstration
tg <- trans_diff$new(dataset = mx, method = "rf", group = "Group", p_adjust_method = "none",taxa_level = "Species")





#correlationheatmap # puplication
dim(dt_env)
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:23])
t1$cal_cor(use_data = "Species", p_adjust_method = "none", p_adjust_type = "Env")
# default ggplot2 method with clustering
t1$plot_cor(color_palette = col, xtext_size = 8)

png("Group_AS_heatmap_cor2xx2x_ISRxx.png", width=25, height=5, units="in", res=300)

t1$plot_cor()

dev.off()




# filter genera that donot have at least one ***
t1$plot_cor(filter_feature = c(""))
#important taxa detected in the biomarker analysis


mx$sample_table

# first create trans_diff object as a demonstration
t2 <- trans_diff$new(dataset = mx, method = "rf", group = "Group",p_adjust_method = "none", taxa_level = "Species", lefse_subgroup = NULL)
t2
dim(dt_env)
# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:5000])
t1
# use other_taxa to select taxa you need
t1$cal_cor(use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:15])
t1$res_cor  
t1$plot_cor()         

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor(pheatmap = TRUE, color_palette = col)

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa[1:15])
# return t1$res_cor
t1$plot_cor(pheatmap = TRUE , color_palette = col)
mx$sample_table$Group
xxr<-t1$res_cor
write.csv(xxr, "resultcorrelationRFCPG_micrbiome_ISR.csv")
xxr

# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)

t1$plot_cor()


png("RF_heatmap_cor2xx2xgroupx21d13_RFx2.png", width=16, height=6, units="in", res=300)

t1$plot_cor(color_palette = col,xtext_angle = 75, xtext_size = 8)

dev.off()


png("Group_AS_heatmap_cor2.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = F )

dev.off()

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)

t1$plot_cor(pheatmap = T )

dev.off()




dim(t2$res_abund) #P.unadj #P.adj

# then create trans_env object
t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:40])
t1$data_env
# use other_taxa to select taxa you need # fdr

#holm, hochberg, hommel, bonferroni, BH, BY, fdr, none

t1$cal_cor(use_data = "other", p_adjust_method = "none",other_taxa = t2$res_diff$Taxa)
t1$plot_cor()

# clustering heatmap; require pheatmap package
# Let's take another color pallete
t1$plot_cor() 
g1<-t1$plot_cor()
g1 + theme(axis.title.x = element_text(size = 0.4))



# calculate correlations for different groups using parameter by_group
t1$cal_cor(by_group = "Group", use_data = "other", p_adjust_method = "none", other_taxa = t2$res_diff$Taxa)
# return t1$res_cor
t1$plot_cor(color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")), cex = 0.01)




# Complexheatmap
library(ComplexHeatmap)
library(pheatmap)
dt1<-read.csv("metabolite-micrrbiome_dataT.csv", row.names = 1, check.names = F)
dt1<-read.csv("metabolite-micrrbiome_dataT23x2x.csv", row.names = 1, check.names = F)
d<-scale(dt1)
write.csv(d,"metabolite-micrrbiome_dataT23x2x.csv" )
dim(dt1)
dt3<-scale(dt1[1:21,])
dt2<-scale(dt1[22:64,])
pheatmap(dt2) 
pheatmap(dt3)
dt1<-read.csv("metabolite-micrrbiome_dataT23x2x.csv", row.names = 1, check.names = F)
dt1<-
d1<-read.csv("Group_design.csv", row.names = 1)
d2<-read.csv("batch_microbime_SP.csv", row.names = 1)
rownames(d1)
rownames(d2)


annotation_col = d1
annotation_col
rownames(annotation_col) = rownames(d1)
rownames(annotation_col)

d2

annotation_row = d2
annotation_row
rownames(annotation_row) = rownames(d2)

ann_colors = list(
    Group = c(Control = "#1B9E77", Asthmatic = "#D95F02"),
  Class = c(Microbiome = "#7570B3", Metabolite = "#E7298A"))


pheatmap(dt1, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors, name = "Abundent")


png("Samplewise heatmap_metaboliteand species23.png", width=10, height=15, units="in", res=300)

pheatmap(dt1, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors, name = "Abundent", cluster_rows = F, cluster_cols = T)



dev.off()
install.packages(omu)
library(omu)




























f<-read.csv("metabolite_micrbiome.scaled.csv", row.names = 1, check.names = F)
b<-read.csv("batch_microbime_SP.csv", row.names = 1)
b$batch<-as.factor(b$batch)
dim(b)
dim(f)
f
library(sva)
# parametric adjustment
combat_gdata2 = ComBat(dat= f, batch=batch, mod=NULL, par.prior=TRUE, prior.plots=FALSE)
combat_gdata2
write.csv(combat_gdata, "metabolite_micrbiome.scaled.sva2.csv" )
































install.packages("RJSONIO")
install.packages(system.file("extdata", "biom_0.3.12.tar.gz", package="microeco"), repos = NULL, type = "source")
install.packages(system.file("extdata", "qiimer_0.9.4.tar.gz", package="microeco"), repos = NULL, type = "source")
install.packages(system.file("extdata", "Tax4Fun_0.3.1.tar.gz", package="microeco"), repos = NULL, type = "source")

#Tax4Fun functional prediction. 
library(RJSONIO)

t1$plot_cor()

install.packages("paletteer")
library("paletteer")

# examples
paletteer_d("RColorBrewer::Spectral")
paletteer_d("RColorBrewer::Set3")
paletteer_d("RColorBrewer::Paired")
paletteer_d("ggsci::nrc_npg")
paletteer_d("ggsci::default_aaas")
x<-paletteer_d("ggsci::lanonc_lancet")
paletteer_d("ggsci::default_nejm")
paletteer_d("ggsci::category10_d3")
paletteer_d("ggthemes::Classic_10_Light")
paletteer_d("ggthemes::Classic_10_Medium")
paletteer_d("ggthemes::Classic_Cyclic")
# 20 color values
paletteer_d("ggsci::category20c_d3")
paletteer_d("ggsci::category20_d3")
paletteer_d("ggthemes::Classic_20")

t1$plot_bar(color_values = paletteer_d("ggsci::lanonc_lancet"))


t3 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:30])
t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = "spearman")
t3$plot_cor(pheatmap = TRUE)



# alpha diversity and metabolite analysis 


t1 <- trans_env$new(dataset = mx, add_data = dt_env[, 1:30])
# use add_abund_table parameter to add the extra data table
t1$cal_cor(add_abund_table = mx$alpha_diversity)
# try to use ggplot2 with clustering plot
# require ggtree and aplot packages 
t1$plot_cor(cluster_ggplot = "both")

# futher analyssis metabolites 

# regression with type = "lm", use group parameter for different groups
t1$plot_scatterfit(
  x = dataset$beta_diversity$bray[rownames(t1$data_env), rownames(t1$data_env)],
  y = "pH",
  type = "lm", 
  group = "Group", 
  group_order = c("CW", "TW", "IW"),
  point_size = 3, point_alpha = 0.3, line_se = FALSE, line_size = 1.5, shape_values = c(16, 17, 7),
  y_axis_title = "Euclidean distance of pH", x_axis_title = "Bray-Curtis distance"
) + theme(axis.title = element_text(size = 17))











# Let's create a microtable object with more information

mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
mx
class(mx)
row.names(samples_df)
colnames(otu_mat)
#write.csv(otu_mat, "OTU_species_abundance_allData3.csv") # matching rowand colnames
# Let's create a microtable object with more information

mx$tidy_dataset()
mx$sample_sums() %>% range

# As an example, use 10000 sequences in each sample
mx$rarefy_samples(sample.size = 10000)
mx$sample_sums() %>% range
mx$save_table(dirpath = "basic_files", sep = ",")
# use default parameters
mx$cal_abund()
# return dataset$taxa_abund
class(mx$taxa_abund)
mx$taxa_abund$class[1:5, 1:5]
mx$save_abund(dirpath = "taxa_abund")



# create trans_abund object
# select top 8 abundant Phyla.
tr <- trans_abund$new(dataset = mx, taxrank = "Species", ntaxa = 8)
tr$plot_bar(others_color = "grey70", facet = "Group", xtext_keep = FALSE, legend_text_italic = FALSE)

# require package ggh4x, first run install.packages("ggh4x") if not installed
tr$plot_bar(others_color = "grey70", facet = c("Group", "Type"), xtext_keep = FALSE, legend_text_italic = FALSE, barwidth = 1)

tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 8)
# require ggalluvial package
# use_alluvium = TRUE make the alluvial plot, clustering =TRUE can be used to reorder the samples by clustering
# bar_type = "notfull" can discard 'others'; select another color palette
p <- tr$plot_bar(bar_type = "notfull", use_alluvium = TRUE, clustering = TRUE, xtext_angle = 30, xtext_size = 3, color_values = RColorBrewer::brewer.pal(8, "Set2"))
#p

# The groupmean parameter can be used to obtain the group-mean barplot.
tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 10, groupmean = "Group")
g1 <- tr$plot_bar(others_color = "grey70", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 18))

# show 15 taxa at Class level
tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 15)
tr$plot_box(group = "Group", xtext_angle = 30)

# show 40 taxa at Genus level
tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 40)
tr$plot_heatmap(facet = "Group", xtext_keep = FALSE, withmargin = FALSE)


tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 8, groupmean = "Group")
# all pie chart in one row
tr$plot_pie(facet_nrow = 1)
tr$plot_pie(facet_nrow = 1, add_label = TRUE)


tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 8, groupmean = "Group")
tr$plot_donut(label = FALSE)
tr$plot_donut(label = TRUE)


tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 8, groupmean = "Group")
tr$plot_radar(values.radar = c("0%", "25%", "50%"), grid.min = 0, grid.mid = 0.25, grid.max = 0.5)
tr <- trans_abund$new(dataset = mx, taxrank = "class", ntaxa = 8, groupmean = "Type")
tr$plot_radar(values.radar = c("0%", "25%", "50%"), grid.min = 0, grid.mid = 0.25, grid.max = 0.5)

#Diversity-based class
tr <- trans_alpha$new(dataset = mx, group = "Group")
# return t1$data_stat
head(tr$data_stat)

tr$cal_diff(method = "KW")
# return t1$res_diff
head(tr$res_diff)

# more options
tr$cal_diff(method = "KW_dunn", KW_dunn_letter = FALSE)
head(tr$res_diff)
tr$cal_diff(method = "wilcox")
head(tr$res_diff)
tr$cal_diff(method = "t.test")
head(tr$res_diff)



tr$cal_diff(method = "wilcox")
# y_increase can adjust the distance from the letters to the highest point
tr$plot_alpha(measure = "Chao1", y_increase = 0.3)
t1$plot_alpha(measure = "Chao1", y_increase = 0.1)
# add_sig_text_size: letter size adjustment
tr$plot_alpha(measure = "Chao1", add_sig_text_size = 6, boxplot_add = "jitter", order_x_mean = TRUE)


tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Chao1", shape = "Group")
# y_start: starting height for the first label
# y_increase: increased height for each label
tr$plot_alpha(measure = "Chao1", shape = "Group", y_start = 0.1, y_increase = 0.1)

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "Chao1", boxplot_add = "dotplot", xtext_size = 15)


tr <- trans_alpha$new(dataset = mx, group = "Group", by_group = "Group_Type")
tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Shannon")

tr$res_diff %<>% base::subset(Significance != "ns")
tr$plot_alpha(measure = "Chao1", boxplot_add = "dotplot", xtext_size = 15)

tr <- trans_alpha$new(dataset = mx, group = "Group", by_group = "Group_Type")
tr$cal_diff(method = "wilcox")
tr$plot_alpha(measure = "Shannon")


# require rcompanion package to be installed
tr$cal_diff(method = "scheirerRayHare", formula = "Group+Group_Type")
dx<-read.csv("Sample_species_clincaldata.csv", row.names = 1)
dx
#Explainable class
# add_data is used to add the environmental data
tr <- trans_env$new(dataset = mx, add_data = dx[, 1:5])
new_test <- clone(mx)
new_test$sample_table <- data.frame(new_test$sample_table, dx[rownames(new_test$sample_table), ])
# now new_test$sample_table has the whole data
new_test

tr <- trans_env$new(dataset = new_test, env_cols = 1:5)
# use Wilcoxon Rank Sum Test as an example
tr$cal_diff(group = "AR_type", method = "wilcox")
head(tr$res_diff)


tr$cal_diff(method = "wilcox", group = "AR_type")
# place all the plots into a list
# require GGally package to be installed
tr$cal_autocor()
tr$cal_autocor(group = "Group")


# use bray-curtis distance for dbRDA
tr$cal_ordination(method = "dbRDA", use_measure = "bray")
# show the orginal results
tr$trans_ordination()
tr$plot_ordination(plot_color = "Group")
# the main results of RDA are related with the projection and angles between arrows
# adjust the length of the arrows to show them better
tr$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
# t1$res_rda_trans is the transformed result for plotting
tr$plot_ordination(plot_color = "Group")

tr$cal_ordination_anova()
tr$cal_ordination_envfit()



# use Genus
tr$cal_ordination(method = "RDA", taxa_level = "class")
# select 10 features and adjust the arrow length
tr$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2)
# t1$res_rda_trans is the transformed result for plot
tr$plot_ordination(plot_color = "Group")



tr$plot_ordination(plot_color = "Group", plot_shape = "Group")
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "centroid"))
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull"))
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse", "centroid"))
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "chull", "centroid"), add_sample_label = "")
tr$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "centroid", centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1)
tr$plot_ordination(plot_color = "Type", plot_type = c("point", "centroid"), centroid_segment_linetype = 1)

# default ggplot2 method with clustering
tr$cal_mantel(use_measure = "bray")
# return t1$res_mantel
head(tr$res_mantel)

# mantel test for different groups
tr$cal_mantel(by_group = "Group", use_measure = "bray")
# partial mantel test
tr$cal_mantel(partial_mantel = TRUE)
tr <- trans_env$new(dataset = mx, add_data = dx[, 1:5])
# 'p_adjust_type = "Env"' means p adjustment is performed for each environmental variable separately.
tr$cal_cor(use_data = "class", p_adjust_method = "fdr", p_adjust_type = "Env")

# default ggplot2 method with clustering
tr$plot_cor()

# filter genera that donot have at least one ***
tr$plot_cor(filter_feature = c("", "*", "**"))


tr$plot_cor()


# first create trans_diff object as a demonstration
tr1 <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "class")
# then create trans_env object
tr <- trans_env$new(dataset = mx, add_data = dx[, 1:5])
# use other_taxa to select taxa you need
tr$cal_cor(use_data = "other", p_adjust_method = "fdr", other_taxa = tr1$res_diff$Taxa[1:30])
t1$plot_cor()

# clustering heatmap; require pheatmap package
# Let's take another color pallete
tr$plot_cor(pheatmap = TRUE, color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")))




# install the required packages
# aplot: one dependency of the trans_venn class of microeco package
# agricolae: for Duncan's new multiple range test
packages <- c("meconetcomp", "rgexf", "pheatmap", "aplot", "agricolae")
# Now check or install
for(x in packages){
  if(!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
  }
}


library(microeco)
library(meconetcomp)
# use pipe operator in magrittr package
library(magrittr)
library(igraph)
library(ggplot2)
# load soil amplicon sequencing dataset


# first create a list
soil_amp_network <- list()
# select samples of "IW" group
# use clone to get a deep copy of soil_amp (R6 object)
tm1 <- clone(dx)
# change sample_table directly
tmp$sample_table %<>% subset(Group == "IW")
# trim all files in the object
tmp$tidy_dataset()
# use filter_thres parameter to filter the feature with low relative abundance
tmp <- trans_network$new(dataset = tmp, cor_method = "spearman", filter_thres = 0.0005)
# COR_p_thres represents the p value threshold
# COR_cut denotes the correlation coefficient threshold
tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
# put the network into the list
soil_amp_network$IW <- tmp
# select samples of "TW" group
tmp <- clone(soil_amp)
tmp$sample_table %<>% subset(Group == "TW")
tmp$tidy_dataset()
tmp <- trans_network$new(dataset = tmp, cor_method = "spearman", filter_thres = 0.0005)
tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
soil_amp_network$TW <- tmp
# select samples of "CW" group
tmp <- clone(soil_amp)
tmp$sample_table %<>% subset(Group == "CW")
tmp$tidy_dataset()
tmp <- trans_network$new(dataset = tmp, cor_method = "spearman", filter_thres = 0.0005)
tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
soil_amp_network$CW <- tmp
# Now we have the list soil_amp_network

#Model-based class
mx <- microtable$new(sample_table = samples_df, otu_table = otu_mat, tax_table = tax_mat)
mx



tr <- trans_diff$new(dataset = mx, method = "lefse", group = "Group", alpha = 0.1, lefse_subgroup = NULL, p_adjust_method = "none")
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
tr$plot_diff_bar(threshold = 2)
# we show 20 taxa with the highest LDA (log10)
tr$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))

# show part of the table
tr$res_diff[1:5, c(1, 3, 4, 6)]
tr$plot_diff_abund(use_number = 1:20, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))


# use Genus level for parameter taxa_level, if you want to use all taxa, change to "all"
tr <- trans_diff$new(dataset = mx, method = "rf", group = "Group", taxa_level = "class", p_adjust_method = "none")

# plot the MeanDecreaseGini bar
# group_order is designed to sort the groups
g1 <- tr$plot_diff_bar(use_number = 1:20, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))
# plot the abundance using same taxa in g1
g2 <- tr$plot_diff_abund(group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"), select_taxa = tr$plot_diff_bar_taxa)
# now the y axis in g1 and g2 is same, so we can merge them
# remove g1 legend; remove g2 y axis text and ticks
g1 <- g1 + theme(legend.position = "none")
g2 <- g2 + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
g2

gridExtra::grid.arrange(g1, g2, ncol = 2, nrow = 1, widths = c(2, 1.7))


tr <- trans_diff$new(dataset = mx, method = "wilcox", group = "Group", taxa_level = "class", filter_thres = 0.001)
# filter something not needed to show
tr$res_diff %<>% subset(Significance %in% "*")
tr$plot_diff_abund(use_number = 1:10, add_sig = T, add_sig_label = "Significance")


tr <- trans_diff$new(dataset = mx, method = "wilcox", group = "Group", taxa_level = "class", filter_thres = 0.00002)
tr$plot_diff_abund(use_number = 1:10, add_sig = T, coord_flip = F)
#trans_network class
# default pearson or spearman correlation invoke R base cor.test, a little slow
tr <- trans_network$new(dataset = mx, cor_method = "spearman", filter_thres = 0.001)
# require WGCNA package
if(!require("WGCNA")) install.packages("WGCNA", repos = BiocManager::repositories())
tr <- trans_network$new(dataset = mx, cor_method = "spearman", use_WGCNA_pearson_spearman = TRUE, filter_thres = 0.0001)
# construct network; require igraph package
tr$cal_network(COR_p_thres = 0.01, COR_optimization = TRUE)
# use arbitrary coefficient threshold to contruct network
tr$cal_network(COR_p_thres = 0.01, COR_cut = 0.7)

# invoke igraph cluster_fast_greedy function for this undirected network 
tr$cal_module(method = "cluster_fast_greedy")




# require rgexf package to be installed
tr$save_network(filepath = "network.gexf")
install.packages("rgexf")
library(devtools)
install_github("gvegayon/rgexf")
library(ggtree)
library(rgexf)
library(igraph)

#require ggtree package
tr$plot_diff_cladogram(use_taxa_num = 200, use_feature_num = 50, clade_label_level = 5, group_order = c("ETH+ISR-asthmatic", "ETH+ISR-control"))







data(dataset)
t1 <- trans_func$new(dataset)
t1$cal_spe_func(prok_database = "FAPROTAX")
t1$cal_spe_func_perc(abundance_weighted = TRUE)
# use list to prepare data
tmp <- list()
# transpose res_spe_func_perc to be a data.frame like taxonomic abundance
tmp$func <- as.data.frame(t(t1$res_spe_func_perc), check.names = FALSE)
# assign the list as taxa_abund in your microtable object
dataset$taxa_abund <- tmp
# use trans_diff class to perform differential test
t2 <- trans_diff$new(dataset = dataset, method = "anova", group = "Group", taxa_level = "all")
t2$plot_diff_abund(add_sig = T) + ggplot2::ylab("Relative abundance (%)")


#RDA results output


library(microeco)
data(dataset)
data(env_data_16S)
dataset

t1 <- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11])
t1$cal_ordination(method = "RDA", taxa_level = "Genus")

  
# get the significance of the terms
t1$cal_ordination_anova()
# fit factors onto the ordination to get R2 for each factor
t1$cal_ordination_envfit()
t1$trans_ordination(adjust_arrow_length = TRUE)
g1 <- t1$plot_ordination(plot_color = "Group", plot_shape = "Group")

g1


ggplot2::ggsave("RDA.pdf", g1, width = 8, height = 6.5)
# use capture.output to save output
capture.output(t1$res_ordination_R2, file = "RDA_R2.txt")
capture.output(t1$res_ordination_envfit, file = "RDA_envfit.txt")
# save data.frame objects
write.table(t1$res_ordination_terms, "RDA_anova_termsig.txt", sep = "\t")
write.table(t1$res_ordination_axis, "RDA_anova_axissig.txt", sep = "\t")
write.table(t1$res_ordination_trans$df_sites, "RDA_axis_sample.txt", sep = "\t")
write.table(t1$res_ordination_trans$df_arrows, "RDA_axis_term.txt", sep = "\t")
write.table(t1$res_ordination_trans$df_arrows_spe, "RDA_axis_taxa.txt", sep = "\t")

#trans_diff class


t1 <- trans_diff$new(dataset = dataset, method = "lefse", group = "Group", alpha = 0.01, lefse_subgroup = NULL)
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
t1$plot_diff_bar(threshold = 4)
# we show 20 taxa with the highest LDA (log10)
t1$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("CW", "IW", "TW"))

t1

class(dataset)



data(otu_table_16S)
data(taxonomy_table_16S)
data(sample_info_16S)
data(phylo_tree_16S)
m1 <- microtable$new(otu_table = otu_table_16S)
m1 <- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, 
                     tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S)
# trim the files in the dataset

data(otu_table_16S)
data(taxonomy_table_16S)
data(sample_info_16S)
data(phylo_tree_16S)
taxonomy_table_16S
otu_table_16S
sample_info_16S

m1 <- microtable$new(otu_table = otu_table_16S)
m1 <- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, 
                     tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S)
# trim the files in the dataset
m1$tidy_dataset()

m1
class(m1)






m1$tidy_dataset()



# allow more waiting time to download each package
options(timeout = 1000)
# If a package is not installed, it will be installed from CRAN
# First select the packages of interest
tmp <- c("microeco", "mecoturn", "MASS", "GUniFrac", "ggpubr", "randomForest", "ggdendro", "ggrepel", "agricolae", "igraph", "picante", "pheatmap", "rgexf", 
         "ggalluvial", "ggh4x", "rcompanion", "FSA", "gridExtra", "aplot", "NST", "GGally", "ggraph", "networkD3", "poweRlaw", "ggtern", "SRS", "performance")
# Now check or install
for(x in tmp){
  if(!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
  }
}


install.packages("BiocManager")
install.packages("file2meco", repos = BiocManager::repositories())
install.packages("MicrobiomeStat", repos = BiocManager::repositories())
install.packages("WGCNA", repos = BiocManager::repositories())
BiocManager::install("ggtree")
BiocManager::install("metagenomeSeq")
BiocManager::install("ALDEx2")
BiocManager::install("ANCOMBC")



# download link of the compressed packages archive
# Alternative from Gitee "https://gitee.com/chiliubio/microeco_dependence/releases/download/v0.20.0/microeco_dependence.zip"
url <- "https://github.com/ChiLiubio/microeco_dependence/releases/download/v0.20.0/microeco_dependence.zip"
# allow more time to download the zip file in R
options(timeout = 2000)
# Another way is to open the upper url in browser to download the zip file and move it to the current R working directory
download.file(url = url, destfile = "microeco_dependence.zip")
# uncompress the file in R
tmp <- "microeco_dependence"
unzip(paste0(tmp, ".zip"))
# install devtools
if(!require("devtools", character.only = TRUE)){install.packages("devtools", dependencies = TRUE)}
# run these one by one
devtools::install_local(paste0(tmp, "/", "SpiecEasi-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "mixedCCA-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "SPRING-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "NetCoMi-main.zip"), repos = BiocManager::repositories())
devtools::install_local(paste0(tmp, "/", "beem-static-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "chorddiag-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "ggradar-master.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "ggnested-main.zip"), dependencies = TRUE)
devtools::install_local(paste0(tmp, "/", "ggcor-1-master.zip"), dependencies = TRUE)


install.packages("RJSONIO")
install.packages(system.file("extdata", "biom_0.3.12.tar.gz", package="microeco"), repos = NULL, type = "source")
install.packages(system.file("extdata", "qiimer_0.9.4.tar.gz", package="microeco"), repos = NULL, type = "source")
install.packages(system.file("extdata", "Tax4Fun_0.3.1.tar.gz", package="microeco"), repos = NULL, type = "source")



# Either seqinr or Biostrings package should be installed for reading and writing fasta file
install.packages("seqinr", dependencies = TRUE)
# or install Biostrings from bioconductor https://bioconductor.org/packages/release/bioc/html/Biostrings.html
# Now we show how to read the fasta file
# see https://github.com/ChiLiubio/file2meco to install file2meco
rep_fasta_path <- system.file("extdata", "rep.fna", package="file2meco")
rep_fasta <- seqinr::read.fasta(rep_fasta_path)
# or use Biostrings package
rep_fasta <- Biostrings::readDNAStringSet(rep_fasta_path)
# try to create a microtable object with rep_fasta
data("otu_table_16S")
# In microtable class, all the taxa names should be necessarily included in rep_fasta
otu_table_16S <- otu_table_16S[rownames(otu_table_16S) %in% names(rep_fasta), ]
test <- microtable$new(otu_table = otu_table_16S, rep_fasta = rep_fasta)
test


library(microeco)
library(magrittr)
set.seed(123)
library(ggplot2)

library(limma)
dt2<-read.csv("Microbiome_correlatedCpG.csv", row.names = 1, check.names = FALSE)
dt2<-read.csv("Microbiome_correlatedCpG.sva.csv", row.names = 1, check.names = FALSE)
dt2<-read.csv("DNAm_micrbiomcorrelatedbvaalues.csv", row.names = 1, check.names = FALSE)
dt2<-read.csv("DNAmethylation_CpG_ETH.csv", row.names = 1, check.names = FALSE)

dt2<-read.csv("Top5000_all DEGs_CPGs_revised_SPrelated.csv", row.names = 1, check.names = FALSE)



dim(dt2)



colnames(dt2)
R<-read.csv("Design_All.csv") # ETH+ISR
R<-read.csv("Design_ISRonly_data.csv") #ISR


R<-read.csv("Design_ETH.csv") #ETH
R<-read.csv("Design_all_5000_sprelated.csv") #all



dim(R)

R$Group<-as.factor(R$Group)
dim(dt2)
R$Group
row.names(dt2)[1:4]
# Create the design matrix from the `time_point` variable
des_mat <- model.matrix(~ R$Group)
des_mat
fit <- limma::lmFit(dt2, design = des_mat)
# Apply empirical Bayes to smooth standard errors
fit <- limma::eBayes(fit)
fit

stats_df <- limma::topTable(fit, number = nrow(dt2)) %>%
  tibble::rownames_to_column("ID")


# wilcox.test(x, y, paired = TRUE, alternative = "two.sided")

DEG1 <- as.data.frame(stats_df)
write.csv(DEG1, "DEGs_micrbiome_correlated Cpg.All_revised.csv")
DEG1




library(sva)

datx<-read.csv("Microbiome_correlatedCpG.csv", row.names = 1, check.names = FALSE)
colnames(datx)
b<-read.csv("Design_All.csv")
b$batch<-as.factor(b$Type)
dim(b)
dim(datx)
dim(datx)
batch = b$batch
batch

# parametric adjustment
combat_gdata = ComBat(dat= datx, batch= batch, mod=NULL, par.prior=TRUE, prior.plots=FALSE)
combat_gdata

write.csv(combat_gdata, "Microbiome_correlatedCpG.sva.csv")

# How to create a loop to run multiple regression models
rm(list = ls())
dat<-read.csv("ISR_DAdata23x_AC.csv", row.names = 1, check.names = F)
dat<-read.csv("DA_SP_CorrelatedCpG_All_AS.csv", row.names = 1,check.names = F )

dat<-read.csv("DA_SP_CorrelatedCpG_All_AS_revisedtoop5000CpG_SP.csv", row.names = 1,check.names = F )


dat<-read.csv("OTU_Ethi0_only_species_abundetData_DAAlog10_AS.csv", row.names = 1, check.names = F)
dat<-read.csv("SP_metabolite_assoction_All.csv", row.names = 1, check.names = F)
dat<-read.csv("SP_metabolite_assoction_ETH.csv", row.names = 1, check.names = F)
dat<-read.csv("SP_metabolite_assoction_ISR_AC.csv", row.names = 1, check.names = F)

dat<-read.csv("CytokineEthio_ISR_asthmatic_controllog10x_microbiomedata.csv", row.names = 1, check.names = F)




dat$AR<-as.factor(dat$AR)
dat$Gender<-as.factor(dat$Gender)
dim(dat)
head(dat)
# outcome
out_start=1
out_end= 20
out_nvar=out_end-out_start+1
out_variable=rep(NA, out_nvar)
out_beta=rep(NA, out_nvar)
out_se = rep(NA, out_nvar)
out_pvalue=rep(NA, out_nvar)
# exposure
exp_start=21
exp_end=47
exp_nvar=exp_end-exp_start+1
exp_variable=rep(NA, exp_nvar)
exp_beta=rep(NA, exp_nvar)
exp_se = rep(NA, out_nvar)
exp_pvalue=rep(NA, exp_nvar)
number=1
#For Loop
dat$AR
dat$Gender
dat$Age

library(lme4)
for (i in out_start:out_end){
  outcome = colnames(dat)[i]
  for (j in exp_start:exp_end){
    exposure = colnames(dat)[j]
    model <- lm(get(outcome) ~ get(exposure) + AR + Gender + Age,
                  na.action = na.exclude,
                  data=dat)
    Vcov <- vcov(model, useScale = FALSE)
    beta <- model$coefficients
    se <- sqrt(diag(Vcov))
    zval <- beta / se
    pval <- 2 * pnorm(abs(zval), lower.tail = FALSE)
    
    out_beta[number] = as.numeric(beta[2])
    out_se[number] = as.numeric(se[2])
    out_pvalue[number] = as.numeric(pval[2])
    out_variable[number] = outcome
    number = number + 1
    
    exp_beta[number] = as.numeric(beta[2])
    exp_se[number] = as.numeric(se[2])
    exp_pvalue[number] = as.numeric(pval[2])
    exp_variable[number] = exposure
    number = number + 1
  }
}


#Create a dataframe with results:

outcome = data.frame(out_variable, out_beta, out_se, out_pvalue)
exposure = data.frame(exp_variable, exp_beta, exp_se, exp_pvalue)
exposure
library(tidyverse)
outcome = outcome %>% 
  rename(
    variable = out_variable,
    beta = out_beta,
    se = out_se,
    pvalue = out_pvalue)


exposure = exposure %>% 
  rename(
    variable = exp_variable,
    beta = exp_beta,
    se = exp_se,
    pvalue = exp_pvalue)


all = rbind(outcome, exposure)
all = na.omit(all)
head(all)


data = all %>% 
  mutate(
    type = substr(variable, 1, 2)
  ) %>% 
  spread(type, variable) %>% 
  rename(
    d = dx,
    i = rv
  ) %>% 
  mutate (
    beta = round(beta, 5),
    se = round(se, 5),
    pvalue = round(pvalue, 5)
  ) %>% 
  select(d, i, beta, se, pvalue)
head(data)





write.csv(data,"ETH_metabolite_Rg_exposure_sp_Revisedx.csv" )


dat<-read.csv("ISR_DAdata23x_AC_heatmap_DA_SPrelated.csv", row.names = 1, check.names = F)
dt<-read.csv("ISR_metadata.csv", row.names = 1, check.names = F)

dat<-read.csv("ETH_DA_SP_relatedCpG2.csv", row.names = 1, check.names = F)
dt<-read.csv("Design_ETH2.csv", row.names = 1, check.names = F)


dat<-read.csv("Microbiome_correlatedCpG_sig.csv", row.names = 1, check.names = F)
dt<-read.csv("Design_All2.csv", row.names = 1, check.names = F)



library(pheatmap) ## for heatmap generation
library(tidyverse) ## for data wrangling
library(ggplotify) ## to convert pheatmap to ggplot2
library(heatmaply) ## for constructing interactive heatmap

pheatmap(dat)
pheatmap(dat,scale="row",
         color=colorRampPalette(c("navy", "white", "red"))(50))

dt

pheatmap(dat,scale="row", annotation_col = dt,
         color=colorRampPalette(c("navy", "white", "red"))(50))








# lasso genee selection 
library(glmnet)
library(data.table)
library(hdi)
library(stabs)

genes<-read.csv("ISR_DAdata23x_CpG.csv", row.names = 1)
genes<-as.matrix(genes)
class(genes)
microbes<-read.csv("ISR_DAdata23x_DA.csv", row.names = 1, check.names = F)


y <- microbes #response
x <- genes #predictors
# ## Extract expression of first gene in the matrix
i <- 3 ## replace with 2 or 3 to test other two genes
y_i <- y[,i]
gene_name <- colnames(y)[i]
gene_name


 library(glmnet)
 library(coefplot)

 # lasso Cox
 set.seed(12)
 y <- microbes #response
 x <- genes #p
 
 # ## Extract expression of first gene in the matrix
 i <- 25 ## replace with 2 or 3 to test other two genes
 y_i <- y[,i]
 gene_name <- colnames(y)[i]
 gene_name
 # ## Make sure y_i is numeric before model fitting
 stopifnot(class(y_i) == "numeric")
 
 
 cv.fit <- cv.glmnet(x,y_i, family = "gaussian" , nfold = 10, alpha= 1)
 plot(cv.fit)
 fit <- glmnet(x,y_i, family = "gaussian",
               nfold = 10, alpha= 0)
 plot(fit)
 cv.fit$lambda.min
 
 Coefficients <- coef(fit, s = fit$lambda.min)
 Active.Index <- which(Coefficients != 0)
 Active.Coefficients <- Coefficients[Active.Index]
 coef(cv.fit, s = "lambda.min")
 
 
 # model:
 extract.coef(cv.fit)
 gene_name
 install.packages("PMA")
 
 #Sparse Canonical Correlation analysis
library(CCA)
library(PMA)
library(mixOmics) # call mixOmics library
library(mixOmics) # import the mixOmics library
set.seed(5249) # for reproducibility, remove for normal use
d1<-read.csv("methylationET_10_ASFC0.08padj0.05.csv", row.names = 1, check.names = F)
d2<-read.csv("species_abundetData_DAAlog10_ASFC0.08padj0.05.csv", row.names = 1, check.names = F)
set.seed(5249) # for reproducibility, remove for normal use
d1<-read.csv("DNAmCpGs_ISR.csv", row.names = 1, check.names = F)
d2<-read.csv("ISR_SP_CAA.csv", row.names = 1, check.names = F)







X <- d1
Y<-d2

# set grid search values for each regularisation parameter
grid1 <- seq(0.001, 0.2, length = 10) 
grid2 <- seq(0.001, 0.2, length = 10)
  
# optimise the regularisation parameter values
cv.tune.rcc.xy <- tune.rcc(X, Y, grid1 = grid1, grid2 = grid2, 
                                   validation = "loo")  
  
cv.tune.rcc.xy
  
  
opt.l1 <- cv.tune.rcc.xy$opt.lambda1 # 
opt.l2 <- cv.tune.rcc.xy$opt.lambda2

# formed optimised CV rCCA
CV.rcc.xy2 <- rcc(X, Y, method = "shrinkage",lambda1 = opt.l1, lambda2 = opt.l2) 
  
  
# run the rCCA method using shrinkage
shrink.rcc.xy <- rcc(X,Y, method = 'shrinkage') 
# examine the optimal lambda values after shrinkage 
shrink.rcc.xy$lambda 

# barplot of cross validation method rCCA canonical correlations
plot(CV.rcc.xy2, type = "barplot", main = "Cross Validation", ) 

# barplot of shrinkage method rCCA canonical correlations
plot(shrink.rcc.xy, type = "barplot", main = "Shrinkage") 







plotVar(CV.rcc.xy2, var.names = c(TRUE, TRUE),
        cex = c(3, 3), cutoff = 0.1 ,
        title = 'DA species vs DNAm CpGs,rCCA shrinkage comp 1 - 2')


plotVar(shrink.rcc.nutrimouse, var.names = c(TRUE, TRUE),
        cex = c(4, 4), cutoff = 0.2,
        title = 'Micbiome vs DNA methylation', legend = TRUE)

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)








png("Group_ET_rCCA2xy.png", width=12, height=12, units="in", res=300)

plotVar(shrink.rcc.xy, var.names = c(TRUE, TRUE),
        cex = c(2, 2), cutoff = 0.95 ,
        title = 'Micbiome & DNA methylation,rCCA shrinkage comp 1 - 2')

dev.off()




shrink.rcc.xy$lambda



network(CV.rcc.xy2, comp = 1:2, interactive = F,
        lwd.edge = 2,
        cutoff = 0.5)



cim(CV.rcc.xy2, comp = 1:2, xlab = "genes", ylab = "lipids")















data(nutrimouse)
nutrimouse$diet
nutrimouse$genotype

X <- nutrimouse$lipid # extract all lipid concentration variables
Y <- nutrimouse$gene # extract all gene expression variables
dim(X) #
# produce a heat map of the cross correlation matrix
imgCor(X, Y, sideColors = c("purple", "green")) 
 
 # invalid graphics 
dev.off()
# set grid search values for each regularisation parameter
grid1 <- seq(0.001, 0.2, length = 10) 
grid2 <- seq(0.001, 0.2, length = 10)
# optimise the regularisation parameter values
cv.tune.rcc.nutrimouse <- tune.rcc(X, Y, grid1 = grid1, grid2 = grid2, 
                                   validation = "loo") 
cv.tune.rcc.nutrimouse # examine the results of CV tuning
 
 
 
opt.l1 <- cv.tune.rcc.nutrimouse$opt.lambda1 # extract the optimal lambda values
opt.l2 <- cv.tune.rcc.nutrimouse$opt.lambda2

# formed optimised CV rCCA
CV.rcc.nutrimouse <- rcc(X, Y, method = "ridge", 
                         lambda1 = opt.l1, lambda2 = opt.l2) 
 
# run the rCCA method using shrinkage
shrink.rcc.nutrimouse <- rcc(X,Y, method = 'shrinkage') 
# examine the optimal lambda values after shrinkage 
shrink.rcc.nutrimouse$lambda 
 
# barplot of cross validation method rCCA canonical correlations
plot(CV.rcc.nutrimouse, type = "barplot", main = "Cross Validation", ) 

# barplot of shrinkage method rCCA canonical correlations
plot(shrink.rcc.nutrimouse, type = "barplot", main = "Shrinkage") 
 
# plot the projection of samples for CV rCCA data
plotIndiv(CV.rcc.nutrimouse, comp = 1:2, 
          ind.names = nutrimouse$genotype,
          group = nutrimouse$diet, rep.space = "XY-variate", 
          legend = TRUE, title = '(a) Nutrimouse, rCCA CV XY-space')

# plot the projection of samples for shrinkage rCCA data
plotIndiv(shrink.rcc.nutrimouse, comp = 1:2, 
          ind.names = nutrimouse$genotype,
          group = nutrimouse$diet, rep.space = "XY-variate", 
          legend = TRUE, title = '(b) Nutrimouse, rCCA shrinkage XY-space')
 
 
 
# plot the arrow plot of samples for CV rCCA data
plotArrow(CV.rcc.nutrimouse, group = nutrimouse$diet, 
          col.per.group = color.mixo(1:5),
          title = '(a) Nutrimouse, CV method')

# plot the arrow plot of samples for shrinkage rCCA data
plotArrow(shrink.rcc.nutrimouse, group = nutrimouse$diet, 
          col.per.group = color.mixo(1:5),
          title = '(b) Nutrimouse, shrinkage method')


plotVar(CV.rcc.nutrimouse, var.names = c(TRUE, TRUE),
       cex = c(4, 4), cutoff = 0.5,
       title = '(a) Nutrimouse, rCCA CV comp 1 - 2')

plotVar(shrink.rcc.nutrimouse, var.names = c(TRUE, TRUE),
        cex = c(4, 4), cutoff = 0.5,
        title = '(b) Nutrimouse, rCCA shrinkage comp 1 - 2')



network(CV.rcc.nutrimouse, comp = 1:2, interactive = FALSE,
        lwd.edge = 2,
        cutoff = 0.5)



cim(CV.rcc.nutrimouse, comp = 1:2, xlab = "genes", ylab = "lipids")

nutrimouse$diet


# Lasso analysis in R code
library(glmnet)
dat<-read.csv("OTU_Ethi0_only_species_abundetData_DAAlog10_AS.csv", row.names = 1)
dat$AR<-as.factor(dat$AR)
dat$Gender<-as.factor(dat$Gender)
dim(dat)
dat <- as.matrix(dat)

dim(dat)


# Original Code IN R
results <- lapply(seq_len(ncol(dat)), function(i) {
  list(
    fit_lasso = glmnet(dat[, -i], dat[, i], alpha = 0.9), 
    cvfit = cv.glmnet(dat[, -i] , dat[, i] , nfolds = 5 , alpha = 0.9)
  )
})


# Must use "[[" and "]]" here. 
results[[3L]]$cvfit$lambda.min
coef(results[[3L]]$cvfit, s = "lambda.min") 

lapply(results, function(x) coef(x$cvfit, s = "lambda.min"))

lapply(results, function(x, fun) fun(coef(x$cvfit, s = "lambda.min")), function(x) x[x[, 1L] != 0L, 1L, drop = FALSE])



# Dirichlet Multinomial Mixtures
#Leo Lahti, Sudarshan Shetty et al.
#Community typing with Dirichlet Multinomial Mixtures

library(microbiome)
library(DirichletMultinomial)
library(reshape2)
library(magrittr)
library(dplyr)
# Load example data
data(dietswap)
pseq <- dietswap
pseq
# To speed up, only consider the core taxa
# that are prevalent at 0.1% relative abundance in 50% of the samples
# (note that this is not strictly correct as information is
# being discarded; one alternative would be to aggregate rare taxa)
pseq.comp <- microbiome::transform(pseq, "compositional")
taxa <- core_members(pseq.comp, detection = 0.1/100, prevalence = 50/100)
pseq <- prune_taxa(taxa, pseq)
pseq.comp
# Pick the OTU count matrix
# and convert it into samples x taxa format
dat <- abundances(pseq)
count <- as.matrix(t(dat))

fit <- lapply(1:3, dmn, count = count, verbose=TRUE)

#Check model fit with different number of mixture components using standard information criteria

lplc <- base::sapply(fit, DirichletMultinomial::laplace) # AIC / BIC / Laplace
aic  <- base::sapply(fit, DirichletMultinomial::AIC) # AIC / BIC / Laplace
bic  <- base::sapply(fit, DirichletMultinomial::BIC) # AIC / BIC / Laplace
plot(lplc, type="b", xlab="Number of Dirichlet Components", ylab="Model Fit")
lines(aic, type="b", lty = 2)
lines(bic, type="b", lty = 3)

#Pick the optimal model

best <- fit[[which.min(unlist(lplc))]]
#Mixture parameters pi and theta
mixturewt(best)
#Sample-component assignments
ass <- apply(mixture(best), 1, which.max)
# Contribution of each taxonomic group to each component
for (k in seq(ncol(fitted(best)))) {
  d <- melt(fitted(best))
  colnames(d) <- c("OTU", "cluster", "value")
  d <- subset(d, cluster == k) %>%
    # Arrange OTUs by assignment strength
    arrange(value) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU))) %>%
    # Only show the most important drivers
    filter(abs(value) > quantile(abs(value), 0.8))     
  
  p <- ggplot(d, aes(x = OTU, y = value)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(title = paste("Top drivers: community type", k))
  print(p)
}


?mixOmics
#CCA
library(mixOmics) # import the mixOmics library
set.seed(5249) # for reproducibility, remove for normal use

library(CCA)
data(nutrimouse)
X <- as.matrix(nutrimouse$gene[,1:10])
X <- scale(X)

Y <- as.matrix(nutrimouse$lipid)
dim(X)
dim(Y)
X
Y
cc(X,Y) ## works

X[,1] <- 2 * X[,9] ## column 9 no longer provides unique information

cc(X,Y)

#regularized CCA

res.regul <- estim.regul(X, Y, plt = TRUE,
                         grid1 = seq(0.0001, 0.2, l=51),
                         grid2 = seq(0, 0.2, l=51))



res.regul

estim.regul(X,Y,plt=TRUE) 

# produce a heat map of the cross correlation matrix
imgCor(X, Y, sideColors = c("purple", "green")) 
dev.off()
# set grid search values for each regularisation parameter
grid1 <- seq(0.001, 0.2, length = 10) 
grid2 <- seq(0.001, 0.2, length = 10)

# optimise the regularisation parameter values
cv.tune.rcc.nutrimouse <- tune.rcc(X, Y, grid1 = grid1, grid2 = grid2, 
                                   validation = "loo") 

cv.tune.rcc.nutrimouse # examine the results of CV tuning

opt.l1 <- cv.tune.rcc.nutrimouse$opt.lambda1 # extract the optimal lambda values
opt.l2 <- cv.tune.rcc.nutrimouse$opt.lambda2

# formed optimised CV rCCA
CV.rcc.nutrimouse <- rcc(X, Y, method = "ridge", 
                         lambda1 = opt.l1, lambda2 = opt.l2) 

CV.rcc.nutrimouse


# run the rCCA method using shrinkage
shrink.rcc.nutrimouse <- rcc(X,Y, method = 'shrinkage') 
# examine the optimal lambda values after shrinkage 
shrink.rcc.nutrimouse$lambda 

# barplot of cross validation method rCCA canonical correlations
plot(CV.rcc.nutrimouse, type = "barplot", main = "Cross Validation") 

# barplot of shrinkage method rCCA canonical correlations
plot(shrink.rcc.nutrimouse, type = "barplot", main = "Shrinkage") 



# plot the projection of samples for CV rCCA data
plotIndiv(CV.rcc.nutrimouse, comp = 1:2, 
          ind.names = nutrimouse$genotype,
          group = nutrimouse$diet, rep.space = "XY-variate", 
          legend = TRUE, title = '(a) Nutrimouse, rCCA CV XY-space')

# plot the projection of samples for shrinkage rCCA data
plotIndiv(shrink.rcc.nutrimouse, comp = 1:2, 
          ind.names = nutrimouse$genotype,
          group = nutrimouse$diet, rep.space = "XY-variate", 
          legend = TRUE, title = '(b) Nutrimouse, rCCA shrinkage XY-space')




# plot the arrow plot of samples for CV rCCA data
plotArrow(CV.rcc.nutrimouse, group = nutrimouse$diet, 
          col.per.group = color.mixo(1:5),
          title = '(a) Nutrimouse, CV method')

# plot the arrow plot of samples for shrinkage rCCA data
plotArrow(shrink.rcc.nutrimouse, group = nutrimouse$diet, 
          col.per.group = color.mixo(1:5),
          title = '(b) Nutrimouse, shrinkage method')


#Variable Plots

plotVar(CV.rcc.nutrimouse, var.names = c(TRUE, TRUE),
        cex = c(4, 4), cutoff = 0.8,
        title = '(a) Nutrimouse, rCCA CV comp 1 - 2')

plotVar(shrink.rcc.nutrimouse, var.names = c(TRUE, TRUE),
        cex = c(4, 4), cutoff = 0.2,
        title = 'Micbiome vs DNA methylation', legend = TRUE)

png("Group_AS_heatmap_cor2xRF.png", width=20, height=5, units="in", res=300)



dev.off()



network(CV.rcc.nutrimouse, comp = 1:2, interactive = FALSE,
        lwd.edge = 2,
        cutoff = 0.2, color.edge = color.GreenRed(50))




cim(CV.rcc.nutrimouse, comp = 1:2, xlab = "genes", ylab = "lipids")



legend = TRUE

# buble plots in R 

library(ggpubr)
library(dplyr)
library(tidyr)
library(ggplot2)
data(msleep)
msleep2<-msleep
msleep2

vars <- c('awake', 'sleep_total', 'sleep_rem')

gather(msleep[1:3, c('name', 'vore', vars)], key = variable, value = value, -name, -vore)



# prepare the data: we use the "msleep" dataset which comes with ggplot2
df <- msleep[!is.na(msleep$vore), c('name', 'vore', vars)] %>%  # only select the columns we need from the msleep dataset
  group_by(vore) %>% sample_n(5) %>% ungroup() %>%              # select 5 random rows from each "vore" group as subset
  gather(key = variable, value = value, -name, -vore) %>%       # make a long table format: gather columns in rows
  filter(!is.na(value)) %>%                                     # remove rows with NA-values -> those will be empty spots in the plot
  arrange(vore, name)                                           # order by vore and name

head(df)

# add a "row" column which will be the y position in the plot: group by vore and name, then set "row" as group index
df <- df %>% mutate(row = group_indices_(df, .dots=c('vore', 'name')))
df

# add a "col" column which will be the x position in the plot: group by variable, then set "col" as group index
df <- df %>% mutate(col = group_indices_(df, .dots=c('variable')))





# get character vector of variable names for the x axis. the order is important, hence arrange(col)!
vars_x_axis <- c(df %>% arrange(col) %>% select(variable) %>% distinct())$variable
# get character vector of observation names for the y axis. again, the order is important but "df" is already ordered
names_y_axis <- c(df %>% group_by(row) %>% distinct(name) %>% ungroup() %>% select(name))$name





ggplot(df, aes(x=factor(col), y=factor(row), color=vore, size=value, alpha=value)) +
  geom_point() +    # plot as points
  geom_text(aes(label=value, x=col + 0.25), alpha=1.0, size=3) +   # display the value next to the "balloons"
  scale_alpha_continuous(range=c(0.3, 0.7)) +
  scale_size_area(max_size = 5) +
  scale_x_discrete(breaks=1:length(vars_x_axis), labels=vars_x_axis, position='top') +   # set the labels on the X axis
  scale_y_discrete(breaks=1:length(names_y_axis), labels=names_y_axis) +                 # set the labels on the Y axis
  theme_bw() +
  theme(axis.line = element_blank(),            # disable axis lines
        axis.title = element_blank(),           # disable axis titles
        panel.border = element_blank(),         # disable panel border
        panel.grid.major.x = element_blank(),   # disable lines in grid on X-axis
        panel.grid.minor.x = element_blank())   # disable lines in grid on X-axis




# This function fits all 47,000 LASSO regressions for/on
# each of the corresponding 47k datasets stored in the object
# of that name, then outputs standard regression results which 
# are typically called returned for any regression ran using R
set.seed(11)     # to ensure replicability
library(dplyr)
library(elasticnet)

dfs <- lapply(list.files("sample_obs2", full.names = TRUE, recursive = TRUE), read.csv)

models <- lapply(dfs, function(i) enet(x = as.matrix(select(i, starts_with("X"))), 
                                       y = i$Y, lambda = 0, normalize = FALSE))

coeffs <- lapply(models, function(i) predict(i, 
                                             x = as.matrix(select(i, starts_with("X"))),
                                             s = 0.1, mode = "fraction", type = "coefficients")[["coefficients"]])

coeffs_above_zero <- lapply(coeffs, function(i) i[i > 0])

# Or alternatively to get only the names:
coeffs_above_zero <- lapply(coeffs, function(i) names(i[i > 0]))





# ballon plot in R 

library(dplyr)
library(tidyr)
library(ggplot2)
head(msleep)
vars <- c('awake', 'sleep_total', 'sleep_rem')
gather(msleep[1:3, c('name', 'vore', vars)], key = variable, value = value, -name, -vore)

# prepare the data: we use the "msleep" dataset which comes with ggplot2
df <- msleep[!is.na(msleep$vore), c('name', 'vore', vars)] %>%  # only select the columns we need from the msleep dataset
  group_by(vore) %>% sample_n(5) %>% ungroup() %>%              # select 5 random rows from each "vore" group as subset
  gather(key = variable, value = value, -name, -vore) %>%       # make a long table format: gather columns in rows
  filter(!is.na(value)) %>%                                     # remove rows with NA-values -> those will be empty spots in the plot
  arrange(vore, name)                                           # order by vore and name
df

# add a "row" column which will be the y position in the plot: group by vore and name, then set "row" as group index
df <- df %>% mutate(row = group_indices_(df, .dots=c('vore', 'name')))
df

# add a "col" column which will be the x position in the plot: group by variable, then set "col" as group index
df <- df %>% mutate(col = group_indices_(df, .dots=c('variable')))
df


# get character vector of variable names for the x axis. the order is important, hence arrange(col)!
vars_x_axis <- c(df %>% arrange(col) %>% select(variable) %>% distinct())$variable
# get character vector of observation names for the y axis. again, the order is important but "df" is already ordered
names_y_axis <- c(df %>% group_by(row) %>% distinct(name) %>% ungroup() %>% select(name))$name
names_y_axis


ggplot(df, aes(x=factor(col), y=factor(row), color=vore, size=value, alpha=value)) +
  geom_point() +    # plot as points
  geom_text(aes(label=value, x=col + 0.25), alpha=1.0, size=0) +   # display the value next to the "balloons"
  scale_alpha_continuous(range=c(0.3, 0.7)) +
  scale_size_area(max_size = 5) +
  scale_x_discrete(breaks=1:length(vars_x_axis), labels=vars_x_axis, position='top') +   # set the labels on the X axis
  scale_y_discrete(breaks=1:length(names_y_axis), labels=names_y_axis) +                 # set the labels on the Y axis
  theme_bw() +
  theme(axis.line = element_blank(),            # disable axis lines
        axis.title = element_blank(),           # disable axis titles
        panel.border = element_blank(),         # disable panel border
        panel.grid.major.x = element_blank(),   # disable lines in grid on X-axis
        panel.grid.minor.x = element_blank())   # disable lines in grid on X-axis



#Manhattan Plots

# Load the library

install.packages(ggfastman)
library(qqman)
library(tidyverse)
library(ggfastman)
data("gwas_data")
gwas_data %>% 
  mutate( gr= "Study 1") %>% 
  mutate(pvalue=-log10(pvalue)) %>% 
  # rbind a second study with pvalues with other sign.
  bind_rows(., mutate(., gr= "Study 2",
                      pvalue = -pvalue)) %>% 
  # plot the points 
  fast_manhattan(., build = "hg18", speed = "fast",log10p = F, dodge_x = T,pointsize = 2.1, pixels = c(1000,500)) + 
  # add significance line
  geom_hline(data= . %>% group_by(gr) %>% slice(1), aes(yintercept = ifelse(pvalue>0, -log10(5e-08),log10(5e-08))),color ="deeppink") + 
  facet_wrap(~gr, scales = "free_y",ncol = 1,strip.position = "right")+
  scale_y_continuous(expression(-log[10](italic(p))),breaks= seq(-90,80,10), labels = abs(seq(-90,80,10)), expand = c(0.01, 0))

#Ballon plot
library(ggplot2)
library(ggpubr)
dat<-read.csv("All_metabolite_Rg_exposure_sp_Revised23.csv", row.names = 1, check.names = F)
dat
# Define color palette
my_cols <- c("#0D0887FF", "#6A00A8FF", "#B12A90FF",
             "#E16462FF", "#FCA636FF", "#F0F921FF")
dat$pvalue
ggballoonplot(dat)
dat$pvalue


# Change color according to the value of table cells
ggballoonplot(dat, fill = "Beta")
# Change color according to the value of table cells
ggballoonplot(dat, fill = "value", legend.title = "Beta") +
  scale_fill_gradientn(colors = my_cols)


# Set points size to 8, but change fill color by values
# Sow labels
ggballoonplot(dat, fill = "value", color = "gray",
             show.label = F)+
  gradient_fill(c("blue", "white", "red"))






















